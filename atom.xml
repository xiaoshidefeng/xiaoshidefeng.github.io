<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiaoshidefeng的博客</title>
  <subtitle>一个计算机研究生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.chenwe.top/"/>
  <updated>2019-12-10T14:14:46.294Z</updated>
  <id>http://blog.chenwe.top/</id>
  
  <author>
    <name>ChenWei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Adversarial Examples Are Not Bugs They Are Features</title>
    <link href="http://blog.chenwe.top/2019/12/10/2019/2019-12-10%20Adversarial%20Examples%20Are%20Not%20Bugs%20They%20Are%20Features/"/>
    <id>http://blog.chenwe.top/2019/12/10/2019/2019-12-10 Adversarial Examples Are Not Bugs They Are Features/</id>
    <published>2019-12-10T13:59:42.000Z</published>
    <updated>2019-12-10T14:14:46.294Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍对抗样本的一篇今年上半年的论文《Adversarial Examples Are Not Bugs They Are Features》，观点比较新颖他认为对抗样本并不是模型的bug而是模型的一种特征。</p>
<a id="more"></a>
<p><a href="https://arxiv.org/pdf/1905.02175.pdf" target="_blank" rel="external"><strong>论文阅读地址</strong></a></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>对抗性例子在机器学习中引起了极大的关注，但其存在和普遍性的原因仍不清楚。作者在这篇文章中认为，对抗性样本的存在不是网络架构的问题，而是数据集的一个属性。对抗性漏洞是我们的模型对数据中的一般特征敏感的直接结果。存在着各种各样的输入特征可以预测标签，而其中只有一些特征是人类可以察觉的。</p>
<h2 id="实验方法"><a href="#实验方法" class="headerlink" title="实验方法"></a>实验方法</h2><p>作者构建了两种图像特征：robust和non-robust。<br>Robust features(鲁棒性特征)对应于能够预测真实标签的模式，即使在某些人为预先定义的扰动集造成对抗性扰动的情况下。<br>non-robust features(非鲁棒性特征)对应的模式虽然具有预测性，但在预先定义的扰动集会被攻击者“翻转”，造成指示的分类错误。如果用这些样本去训练，假如该样本人眼认为是狗，但其对应标签为猫，训练好后再拿这个网络去识别猫，却能达到比较好的准确度。<br><img src="https://i.loli.net/2019/12/10/QFUzBcP7ny4ksoC.png" alt="1.png"></p>
<p>左图是对于robust的实验结果，右图是对于non-robust的实验结果。<br>鲁棒和非鲁棒特征都可以用于预测训练集，但只有非鲁棒性特征才会导致对原始测试集的泛化。</p>
<p>作者在没有对抗训练的情况下在结果数据集上训练模型，发现得到的模型具有非常高的准确性和鲁棒性。这与标准训练集的训练形成鲜明对比，后者训练出的模型虽然准确，但非常脆弱。如下图所示<br><img src="https://i.loli.net/2019/12/10/FXq19MiGB7DTjcv.png" alt="2.png"></p>
<p>上图中，左：在 CIFAR-10（D）上正常训练；左2：在 CIFAR-10（D）上的对抗性训练；右2：重新构建的数据集上正常训练（该训练集仅限于包含已经训练过的高鲁棒性模型使用的特征）。右1：重新构建的数据集上正常训练（该训练集仅限于包含已经训练过的非鲁棒性模型使用的特征）。<br>结果表明，鲁棒性（和非鲁棒性）实际上可以作为数据集本身的属性出现。特别是，当我们从原始训练集中去除了非鲁棒性特征时，可以通过标准训练获得高鲁棒性的模型。这进一步证明，对抗性实例是由于非鲁棒性特征而产生的，而且不一定与标准训练框架相关联。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍对抗样本的一篇今年上半年的论文《Adversarial Examples Are Not Bugs They Are Features》，观点比较新颖他认为对抗样本并不是模型的bug而是模型的一种特征。&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.chenwe.top/categories/Machine-Learning/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Threat of Adversarial Attacks on Deep Learning in Computer Vision</title>
    <link href="http://blog.chenwe.top/2019/12/05/2019/2019-12-05%20Threat%20of%20Adversarial%20Attacks%20on%20Deep%20Learning%20in%20Computer%20Vision/"/>
    <id>http://blog.chenwe.top/2019/12/05/2019/2019-12-05 Threat of Adversarial Attacks on Deep Learning in Computer Vision/</id>
    <published>2019-12-05T12:10:37.564Z</published>
    <updated>2019-12-06T07:22:18.323Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍对抗样本的一篇调查型论文《Threat of Adversarial Attacks on Deep Learning in Computer Vision: A Survey Naveed》。</p>
<a id="more"></a>
<p><a href="https://arxiv.org/pdf/1801.00553" target="_blank" rel="external"><strong>论文阅读地址</strong></a></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>深度学习的火热推动计算机视觉领域的发展，但近年来的研究发现，深度学习对于一些微小的扰动导致的预测输出错误的对抗样本攻击具有脆弱性，对抗性攻击对深度学习的成功构成了严重威胁。这篇论文介绍了有关计算机视觉中深度学习的对抗性攻击的首次全面调查。</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>深度学习在计算机视觉等多个领域取得巨大成功，并应用在日常生活中。Szegedy 首先发现了深度神经网络一个有趣的软肋：对图像做一个微小的扰动，尽管人类的视觉无法区分，但是深度学习分类器以高置信度做出了一个错误的判断。自此以后，该领域吸引了一大批研究者进入，来探究深度学习对抗攻击的攻击和防御。<br><img src="https://i.loli.net/2019/12/06/qFkVZQ29KYDeLrg.png" alt="1.png"><br>如上图所示，不同的网络结构对于对抗样本的攻击都具有脆弱性。</p>
<h2 id="对抗攻击方法"><a href="#对抗攻击方法" class="headerlink" title="对抗攻击方法"></a>对抗攻击方法</h2><p>Box-constrained L-BFGS：<br>Szegady等人首次证明了图片的微小扰动的存在，通过L-BFGS方法来找到扰动，BFGS方法类似于牛顿法通过迭代来逼近，而L-BFGS是舍弃部分内容的BFGS，提高计算效率。</p>
<p>Fast Gradient Sign Method (FGSM)：<br>Goodfellow提出了有效生成对抗样本的方法 $\eta =\epsilon sign(\nabla_xJ(\theta,x,y ) )$，类似梯度下降的方法，通过在梯度方向上进行添加增量来诱导网络对生成的图片进行误分类。</p>
<p>Basic &amp; Least-likely-class Iterative Methods：<br>one-step 方法通过一大步运算增大分类器的损失函数而进行图像扰动，因而可以直接将其扩展为通过多个小步增大损失函数的变体，从而得到 Basic Iterative Methods。</p>
<p>Jacobian-based Saliency Map Attack：<br>仅改变几个像素的值，而不是扰动整张图像，来产生对抗样本。像素的数目有一个阈值。</p>
<p>One Pixel Attack：<br>一种极端的对抗攻击方法，仅改变图像中的一个像素值就可以实现对抗攻击。<br><img src="https://i.loli.net/2019/12/06/lJgVrdFI7Q6NEOp.png" alt="2.png"></p>
<p>Carlini and Wagner Attacks：<br>是一个基于优化的攻击，它的优点在于，可以调节置信度，生成的扰动小，可以破解很多的防御方法。</p>
<p>DeepFool：<br>通过迭代计算的方法生成最小规范对抗扰动，将位于分类边界内的图像逐步推到边界外，直到出现错误分类。作者证明他们生成的扰动比 FGSM 更小，同时有相似的欺骗率。</p>
<p>Universal Adversarial Perturbations：<br>诸如 FGSM 、 ILCM 、 DeepFool  等方法只能生成单张图像的对抗扰动，而 Universal Adversarial Perturbations 能生成对任何图像实现攻击的扰动，这些扰动同样对人类是几乎不可见的。</p>
<p>UPSET and ANGRI：<br>两个黑箱攻击算法，UPSET 和 ANGRI。UPSET 可以为特定的目标类别生成对抗扰动，使得该扰动添加到任何图像时都可以将该图像分类成目标类别。</p>
<p>Houdini：<br>Houdini是一种用于欺骗基于梯度的机器学习算法的方法，通过生成特定于任务损失函数的对抗样本实现对抗攻击，即利用网络的可微损失函数的梯度信息生成对抗扰动。除了图像分类网络，该算法还可以用于欺骗语音识别网络。</p>
<p>Adversarial Transformation Networks：<br>训练多个前向神经网络来生成对抗样本，可用于攻击一个或多个网络。</p>
<p>攻击的一些总结如下表：<br><img src="https://i.loli.net/2019/12/06/Jxhl3gVyGpYiRFq.png" alt="3.png"></p>
<h2 id="现实场景下的对抗攻击"><a href="#现实场景下的对抗攻击" class="headerlink" title="现实场景下的对抗攻击"></a>现实场景下的对抗攻击</h2><p>Attacks on Face Attributes 面部特征攻击。<br>人脸图像的性别(性别分类器)被修改，而人脸匹配系统的生物识别功能保持不变，下面为图例：</p>
<p><img src="https://i.loli.net/2019/12/06/bX4sljxzETgSf6w.png" alt="4.png"></p>
<p>Cell-phone camera attack 手机相机攻击：<br>Kurakin等首先证明了对抗性攻击的威胁也存在于物质世界中。为了说明这一点，他们打印了对抗性的图像，并从手机摄像头拍下了快照。这些图像进行对象分类。结果显示，即使是通过相机，也有很大一部分图像被错误分类。下面为图例：<br><img src="https://i.loli.net/2019/12/06/TD842Zb1Xya7r3N.png" alt="5.png"></p>
<p>Road sign attack 路标攻击：<br>攻击者打印一个路标扰动图像替换真正标志或者贴纸扰动，打印一些贴纸形成扰动。下面为图例：<br><img src="https://i.loli.net/2019/12/06/YldGtKjFMTyeWP8.png" alt="6.png"></p>
<h2 id="对抗样本的存在性分析"><a href="#对抗样本的存在性分析" class="headerlink" title="对抗样本的存在性分析"></a>对抗样本的存在性分析</h2><p>这部分讲了为什么会存在对抗样本的原因，这部分是目前学术界有争议的话题，主要有以下几个观点：</p>
<ol>
<li>Limits on adversarial robustness </li>
<li>Space of adversarial examples </li>
<li>Boundary tilting perspective </li>
<li>Prediction uncertainty and evolutionary stalling of training cause adversaries</li>
<li>Accuracy-adversarial robustness correlation</li>
<li>More on linearity as the source</li>
<li>Existence of universal perturbations</li>
</ol>
<h2 id="对抗攻击防御"><a href="#对抗攻击防御" class="headerlink" title="对抗攻击防御"></a>对抗攻击防御</h2><p>这部分讲对于对抗攻击的防御，主要有三个方向：</p>
<ul>
<li>在学习过程中修改训练过程或者在测试阶段修改的输入样本。</li>
<li>修改网络，比如：添加更多层/子网络、改变损失/激活函数等。</li>
<li>当分类未见过的样本时，用外部模型作为附加网络。</li>
</ul>
<p>具体分类如下图<br><img src="https://i.loli.net/2019/12/06/gEM5JUvG3muQzaB.png" alt="7.png"></p>
<h2 id="研究方向展望"><a href="#研究方向展望" class="headerlink" title="研究方向展望"></a>研究方向展望</h2><p>作者通过这次调查总结以下对抗攻击的特点与一些方向：</p>
<ol>
<li>对抗攻击的威胁是真实存在的</li>
<li>对抗的脆弱性是普遍存在的</li>
<li>对抗样本有不错的泛化性</li>
<li>对于对抗的脆弱性需要进一步研究</li>
<li>线性确实会增加脆弱性</li>
</ol>
<p>深度神经网络容易受到对抗性干扰的深刻暗示，使得对抗性攻击及其防御的研究在最近变得非常活跃。 在本次调查中回顾的大多数文献是在最近两年浮出水面的，并且目前有不断涌入的文献朝这个方向发展。 一方面，提出了一些技术来保护神经网络免受已知攻击。 同时正在设计更多且更强大的攻击。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍对抗样本的一篇调查型论文《Threat of Adversarial Attacks on Deep Learning in Computer Vision: A Survey Naveed》。&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.chenwe.top/categories/Machine-Learning/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>DeepFool</title>
    <link href="http://blog.chenwe.top/2019/11/20/2019/2019-11-20%20DeepFool%E7%AE%80%E6%9E%90/"/>
    <id>http://blog.chenwe.top/2019/11/20/2019/2019-11-20 DeepFool简析/</id>
    <published>2019-11-20T11:18:35.240Z</published>
    <updated>2019-11-21T10:11:06.264Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍产生对抗样本的一种算法Deep Fool的论文《DeepFool: a simple and accurate method to fool deep neural networks》。</p>
<a id="more"></a>
<p><a href="https://arxiv.org/pdf/1511.04599" target="_blank" rel="external"><strong>论文阅读地址</strong></a></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>现有的对抗样本尚未提出有效的方法来准确计算最新的深度分类器对大规模数据集的这种扰动的鲁棒性。作者这篇文章填补了这方面的空白，并提出了DeepFool算法，来获得对于深层网络有作用的扰动。</p>
<h2 id="分类器鲁棒性的评估指标"><a href="#分类器鲁棒性的评估指标" class="headerlink" title="分类器鲁棒性的评估指标"></a>分类器鲁棒性的评估指标</h2><p>作者定义分类器在x处的鲁棒性:</p>
<script type="math/tex; mode=display">
\Delta(x;\hat{k}):=\min_{\textbf{r}}\left||\textbf{r}|\right|_2 \ \ s.t.\hat{k}(x+\textbf{r})\neq\hat{k}(x)</script><p>其中 x代表图像样本，$\hat{k}(x)$是分类器，r是对抗的干扰。<br>分类器$\hat{k}(x)$的鲁棒性可以用</p>
<script type="math/tex; mode=display">
\rho_{adv}(\hat{k})=\mathbb{E}_{x}\dfrac{\Delta(x;\hat{k})}{||x||_2}</script><p>来表示。</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul>
<li>提出了一种简单而准确的方法来计算和比较不同分类器对于对抗扰动的鲁棒性。</li>
<li>作者的方法比现有的方法更可靠、更有效地计算了对抗性扰动。</li>
<li>发现用对抗性的例子增加训练数据可以显著增强对对抗性扰动的鲁棒性。</li>
<li>使用不精确的方法来计算对抗性扰动，可能导致不同结论，有时还会产生误导。</li>
</ul>
<h2 id="DeepFool在二分类问题的应用"><a href="#DeepFool在二分类问题的应用" class="headerlink" title="DeepFool在二分类问题的应用"></a>DeepFool在二分类问题的应用</h2><p>由于多分类器可以看作是二分类器的延申，所以作者先从二分类器入手。<br>f是一个线性二分类分类器：</p>
<script type="math/tex; mode=display">
f=\textbf{w}^Tx+b</script><p>如下图所示<br><img src="https://i.loli.net/2019/11/20/GCWnhb12wZSmkiR.png" alt="1.png"></p>
<p>二维平面被f=0分为两块，一块是f<0，一块是f>0。<br>假设有一个样本点$x_0$，它作为正常的样本，被分在$f&gt;0$的区域中，如果我们想让分类的结果产生错误，那么就要对样本$x_0$添加扰动，为了使得扰动达到最小，最小的方向就是垂直与分类面的方向（这里是垂直与$f=0$这条线）。<br>要达到这个这个扰动的最小距离我们记为$r_*$，我们得出关于$r_*$的公式：</0，一块是f></p>
<script type="math/tex; mode=display">
\textbf{r}_{\star}(\textbf{x}_0):=\arg\min\limits_{\textbf{r}}||\textbf{r}||_2 \\
s.t.\ sign(f(x_0+\textbf{r}))\neq sign(f(x_0)) \\
=-\dfrac{f(x_0)}{||\textbf{w}||_2^2}\textbf{w}</script><p>sign是一个非线性函数，表达式为</p>
<script type="math/tex; mode=display">
sign=\left\{\begin{matrix}
 & 1 & ,x>0 \\ 
 & 0 & ,x=0 \\ 
 & -1 & ,x<0 \\ 
\end{matrix}\right.</script><p>它的函数图像为:<br><img src="https://i.loli.net/2019/11/20/IfqmrCN2MQbPklg.png" alt="3.png"></p>
<p>$r_*$要满足$sign(f(x_0+r)) \neq  sign(f(x_0))$,即当样本$x_0$在$x_0$之后的分类结果不同。</p>
<p>$\dfrac{f(x_0)}{||w||_2^2}{w}$可以拆成如下形式：</p>
<script type="math/tex; mode=display">
\dfrac{f(x_0)}{||w||_2^2}=\frac{f\left ( x_{0} \right )}{\left \| w \right \|_{2}}.\frac{w }{\left \| w \right \|_{2}}</script><p>其中$\frac{f\left ( x_{0} \right )}{\left | w \right |_{2}}$可以理解为，点到平面f的距离乘上它的向量方向(点到线的距离公式为$d=|\frac{Ax_0+By_0+C}{\sqrt{A^2+B^2}}|$，由于$f$只有一个系数$w$，所以$||w||$即$w$平方后开根号)。</p>
<p>如果只是加上$r$的话，那么也只是分类到这条分界线上，所以要添加一个极小的$η$让他超过这条线，分类到错误的地方。作者会将最终的$r$乘以一个常系数$1+η$，在作者的实验中，他选取$η=0.02$。</p>
<p>他的算法流程如下：<br><img src="https://i.loli.net/2019/11/20/rJ57MFjsB1pWNlw.png" alt="4.png"></p>
<h2 id="DeepFool在多分类问题的应用"><a href="#DeepFool在多分类问题的应用" class="headerlink" title="DeepFool在多分类问题的应用"></a>DeepFool在多分类问题的应用</h2><p>作者采用的是one-vs-all的方法将多分类问题转为二分类问题。<br>对于一个多类分类问题，我们的数据集或许看起来像这样:<br><img src="https://i.loli.net/2019/11/20/XkTKOiaHv8hoPpc.png" alt="5.png"><br>上图左边是二分类问题，右边是多分类问题，我们可以使用多个分类器，对于每一个类假设其为正类，然后使用一次二分类的判别算法即可分别得出各个类的分类。如下图<br><img src="https://i.loli.net/2019/11/20/NGageVU3wsmIz24.png" alt="6.png"><br>多分类中，作者采用$\hat{k}(x)=\arg\max\limits_{k}{f_k(x)}$来完成分类，$f_k(x)$是$f(x)$的第k个输出，这里是表示令$f(x)$最大的那个$\hat{k}(x)$。<br>只要在原样本$x_0$上加上扰动r后，满足下式即攻击成功(只要出现某个类的输出置信度高于原类别即满足)</p>
<script type="math/tex; mode=display">
\arg\min\limits_{\textbf{r}}||\textbf{r}||_2 \\
s.t. \exists k: \textbf{w}^T_k(x_0+\textbf{r})+\textbf{b}_k\geq \textbf{w}^T_{\hat{k}(x_0)}(x_0+\textbf{r})+\textbf{b}_{\hat{k}(x_0)}</script><p>对于文中提到的$k(x_0)=4$而言，它的决策边界如下图：<br><img src="https://i.loli.net/2019/11/20/LyWEPfBDXN7eCRl.png" alt="7.png"><br>途中$x_0$是样本点，绿色部分是它能够被正确分类的区域P，他的定义为：</p>
<script type="math/tex; mode=display">
P=\bigcap\limits_{k=1}^{c}\{x:f_{\hat{k}(x_0)}(x)\geq f_{k}(x)\}</script><p>我们只需找到它离他的三个边界最近的距离，即可让他产生错误的分类结果。<br>我们令$l(x_0)$为距离P最近的超平面，可以通过如下公式计算出$l$。</p>
<script type="math/tex; mode=display">
\hat{l}(x_0)=\arg\min\limits_{k\neq \hat{k}(x_0)}\dfrac{|f_k(x_0)-f_{\hat{k}(x_0)}(x_0)|}{||\textbf{w}_{k}-\textbf{w}_{\hat{k}(x_0)}||_2}</script><p>计算出$l$后，可以得出计算扰动的公式如下：</p>
<script type="math/tex; mode=display">
\textbf{r}_{\star}(x_0)=\dfrac{|f_{\hat{l}(x_0)}(x_0)-f_{\hat{k}(x_0)}(x_0)|}{||\textbf{w}_{\hat{l}(x_0)}-\textbf{w}_{\hat{k}(x_0)}||_2^2}(\textbf{w}_{\hat{l}(x_0)}-\textbf{w}_{\hat{k}(x_0)})</script><h2 id="平均鲁棒性"><a href="#平均鲁棒性" class="headerlink" title="平均鲁棒性"></a>平均鲁棒性</h2><p>为了评估分类器$f$的对抗扰动的鲁棒性，作者计算了平均鲁棒性$\hat{p}_{adv}(f)$，定义为：</p>
<script type="math/tex; mode=display">
\hat{p}_{adv}(f)=\frac{1}{|D|}.\sum_{x\in D}{\frac{||\hat{r}(x)||_2}{||x||_2}}</script><p>其中$r$是从DeepFool中获得的最小扰动，$D$是测试集。</p>
<h2 id="对比FGSM算法"><a href="#对比FGSM算法" class="headerlink" title="对比FGSM算法"></a>对比FGSM算法</h2><p>FGSM算法获得扰动的方法为$\hat{r}(x) =\epsilon sign(\nabla_xJ(\theta,x,y ) )$，作者通过对不同数据集的平均鲁棒性比较，得出了以下表格：<br><img src="https://i.loli.net/2019/11/20/OpoZRrwYlFhKn53.png" alt="8.png"><br>发现在同一个数据集下产生同样的效果时，DeepFool的扰动小于FGSM算法的扰动。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍产生对抗样本的一种算法Deep Fool的论文《DeepFool: a simple and accurate method to fool deep neural networks》。&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.chenwe.top/categories/Machine-Learning/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>对抗样本简析</title>
    <link href="http://blog.chenwe.top/2019/11/17/2019/2019-11-17%20%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC%E7%AE%80%E6%9E%90/"/>
    <id>http://blog.chenwe.top/2019/11/17/2019/2019-11-17 对抗样本简析/</id>
    <published>2019-11-17T12:19:22.235Z</published>
    <updated>2019-11-17T13:09:19.926Z</updated>
    
    <content type="html"><![CDATA[<p>本文先介绍对抗样本，再通过这篇经典的对抗样本论文《Explaining and Harnessing Adversarial Examples》讲解一些对抗样本形成的可能原因，以及一个快速生成对抗样本的方法FSGM。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>什么是对抗样本？</strong><br><img src="https://i.loli.net/2019/11/17/MsLb6DGkFeTaIW1.png" alt="1.png"><br>这幅图左边第一眼看着是一直乌鸦，而仔细一看，在对比右边的图片后，我们就能发现这是一直黑猫的图片。我们人的肉眼容易被左边的图片欺骗，对于物体图像产生错误的判断，上面这个图片就是一个对人的对抗样本图片。<br>而我们今天的主角对抗样本它欺骗的对象不是人，而是机器。<br><strong>对抗样本指的是一个经过微小调整就可以让机器学习算法输出错误结果的输入样本。</strong><br><img src="https://i.loli.net/2019/11/17/DQ7lWmViFZc5np2.png" alt="2.png"><br>如上图所示，左边是一张大熊猫的图片，右边也是一张大熊猫的图片，但是左边机器认为是大熊猫，而右边机器认为99.3%是长臂猿。<br>我们在中间加了点非常细微甚至人眼无法察觉的改动，就让机器产生了错误的结果。人工智能瞬间变成了人工智障。<br><img src="https://i.loli.net/2019/11/17/di7xtMf9YF1Jqsn.png" alt="3.png"><br>对抗样本指的是一个经过微小调整就可以让机器学习算法输出错误结果的输入样本。</p>
<p>下面我来介绍一下关于对抗样本的原理的一篇论文<br>《Explaining and Harnessing Adversarial Examples》这是GAN的作者的一篇文章。<br>需要注意的是，目前学术界对于对抗样本的原理与形成原因还没有一个准确的论断，目前还处于争议之中，这篇论文只是提供一种说法而已。</p>
<p><a href="https://arxiv.org/pdf/1412.6572.pdf" target="_blank" rel="external"><strong>论文阅读地址</strong></a></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Szegedy等人于2014年首先发现当前的机器学习模型包括神经网络等模型容易受到对抗样本(Adversarial Examples)的攻击。所谓对抗样本，即攻击者通过轻微地扰动正常样本产生对抗样本，在且保证该攻击不影响人眼的识别的情况下，达到误导分类器的目的。<br>在当前的研究中，对抗样本的原因产生的原因有很多争议。作者在这篇文章里的主要观点是对抗样本的产生是因为高维空间与过于线性的原因。作者还根据这个观点，设计了一种快速产生对抗样本的方法。</p>
<h2 id="对抗样本的原理"><a href="#对抗样本的原理" class="headerlink" title="对抗样本的原理"></a>对抗样本的原理</h2><p>作者认为对抗样本是由于高维空间与过于线性的原因而产生的。<br>因为样本输入特征的精度有限（一些模型通常为了效率会丢弃一些信息），所以当每个输入样本x添加一些小于样本输入精度的干扰值η后，机器将无法准确的区分样本x与x = x +η<br>。如果这些干扰足够小，那么机器将认为x与x 是同一个类。 因为整个模型是高维度的，所以一个样本中大量维度的无限小的干扰加在一起就可以对输出造成很大的变化。因此对抗样本的线性解释表明，对线性模型而言，如果其输入样本有足够大的维度，那么线性模型也容易受到对抗样本的攻击。</p>
<h2 id="构建对抗样本"><a href="#构建对抗样本" class="headerlink" title="构建对抗样本"></a>构建对抗样本</h2><p>作者利用对抗样本的线性解释提出了一个快速产生对抗样本的方式，也即Fast Gradient Sign Method(FGSM)方法。<br>假设模型的参数值为θ，模型的输入是 x， y 是模型对应的label值， J(θ,x,y)是训练神经网络的损失函数。对某个特定的模型参数 θ 而言，FGSM方法将损失函数近似线性化，从而获得保证无穷范数限制的最优的扰动，扰动值具体为：</p>
<script type="math/tex; mode=display">\eta =\epsilon sign(\nabla_xJ(\theta,x,y ) )</script><p>FGSM这种简单的算法确实可以产生误分类的对抗样本，从而证明了作者假设的对抗样本的产生原因是由于模型的线性特性。</p>
<h2 id="Fast-Gradient-Sign-Method"><a href="#Fast-Gradient-Sign-Method" class="headerlink" title="Fast Gradient Sign Method"></a>Fast Gradient Sign Method</h2><p>通过在梯度方向上进行添加增量来诱导网络对生成的图片X’进行误分类。我们可以通过指定我们期待的分类使得网络针对任何输入图片均产生指定分类的对抗样本，同时也可以不指定期待的分类，只需要使得生成的图片被网络识别为与正确分类不同的分类即可。</p>
<h2 id="对抗样本泛化与原因"><a href="#对抗样本泛化与原因" class="headerlink" title="对抗样本泛化与原因"></a>对抗样本泛化与原因</h2><p>目前的对抗样本有一个泛化的特点，即从一个模型中得到的对抗样本，对许多的用不同的数据训练的不同的模型有着同样的作用，也就是一个特定模型上产生的对抗样本通常也容易被其他的模型错误的分类，甚至错误的分类结果相同。<br>在本文的线性解释下，作者认为对抗样本存在与广泛的子空间中。<br><img src="https://i.loli.net/2019/11/17/J7MSZENRT8pWH3o.png" alt="4.png"></p>
<p>如图所示，在不同的ϵ下，可以看到FGSM可以在一堆连续的子空间内产生对抗样本，而不是特定的区域。这也可以说明为什么同一个模型，可以产生很多个对抗样本。<br>为了解释为什么不同的分类器将对抗样本误分类到同一个类，作者假设目前的方法训练神经网络都类似于在同一个训练集上学习的线性分类器。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文先介绍对抗样本，再通过这篇经典的对抗样本论文《Explaining and Harnessing Adversarial Examples》讲解一些对抗样本形成的可能原因，以及一个快速生成对抗样本的方法FSGM。&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.chenwe.top/categories/Machine-Learning/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>GAN简析</title>
    <link href="http://blog.chenwe.top/2019/11/13/2019/2019-11-13%20GAN%E7%AE%80%E6%9E%90/"/>
    <id>http://blog.chenwe.top/2019/11/13/2019/2019-11-13 GAN简析/</id>
    <published>2019-11-13T07:00:55.519Z</published>
    <updated>2019-11-17T12:19:37.945Z</updated>
    
    <content type="html"><![CDATA[<p>本文是这几年大火的GAN的开山之作《Generative Adversarial Nets》的一些阅读总结</p>
<a id="more"></a>
<p><a href="http://papers.nips.cc/paper/5423-generative-adversarial-nets.pdf" target="_blank" rel="external"><strong>论文阅读地址</strong></a></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>作者提出了一种新的模型——生成对抗模型。这个模型其实就是训练两个相互对抗的网络，一个是训练一个生成器(Generator)，另一个是训练一个判别器(Descriminator)。生成器的目的是尽量产生接近真实图片的生成图片，交给判别器来判断是来自真实图像的分布还是是由生成器学习到的分布。两个网络是非合作关系，对于判别器D来说，是要最大化能够判别出生成器G生成的数据是假的的概率，而对于G来说，是要最小化被D判别出来的概率，在这个不断博弈的过程中，两个模型的能力都在变强，最后得到一个均衡。</p>
<h2 id="对抗网络"><a href="#对抗网络" class="headerlink" title="对抗网络"></a>对抗网络</h2><p>生成网络和对抗网络都是用的多层感知机。<br>函数$V(G, D)$如下：<br><img src="https://i.loli.net/2019/11/13/CDU3LsqM86rkVxJ.png" alt="1.png"></p>
<p>这是判别器的优化函数：<br><img src="https://i.loli.net/2019/11/13/L62srdfY4Aca1En.png" alt="2.png"></p>
<p>其中$E$是期望，$P_{data}$是真实数据的分布，z是噪音，$P_z$是原始噪音的分布，$P_g$是经过生成器后的数据分布。$G()$是生成器的函数，$D()$是判别器的函数。X~$P_{data}$是x 服从于data 的概率密度。<br>这是生成器的优化函数：<br><img src="https://i.loli.net/2019/11/13/eNFkTvumbjZoy2M.png" alt="3.png"></p>
<p>对于D而言，要尽可能的大（判别能力强），对于G而言要尽可能的小（生成的数据尽可能的接近真实数据）。优化D的时候，也就是判别网络，其实没有生成网络什么事，后面的$G(z)$这里就相当于已经得到的假样本。优化D的公式的第一项，使的真样本x输入的时候，得到的结果越大越好，可以理解，因为需要真样本的预测结果越接近于1越好。对于假样本，需要优化是的其结果越小越好，也就是$D(G(z))$越小越好。但是第一项越大，第二项越小，这整个公式就有矛盾了，所以把第二项改成$1-D(G(z))$，这样就是前后都越大越好，两者合起来就是越大越好。<br>同理，在优化G的时候，这个时候与真样本无关，所以把第一项直接去掉。时候只有假样本，但是我们希望假样本的标签是尽可能接近1的，所以是$D(G(z))$越大越好，但是为了统一成$1-D(G(z))$的形式，只能是最小化$1-D(G(z))$。<br>因此文章中给出的第一个目标公式是：<br><img src="https://i.loli.net/2019/11/13/k4hnajVFy5S2KLg.png" alt="4.png"></p>
<h2 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h2><p>训练是分别对D和G进行交互迭代，固定G，优化D，一段时间后，固定D再优化G，直到过程收敛。<br><img src="https://i.loli.net/2019/11/13/7p4CHaMd1Dy5Zgo.png" alt="5.png"></p>
<p>真实样本分布、生成样本分布以及判别模型分别是图中的黑线、绿线和蓝线。在训练开始时，判别模型是无法很好地区分真实样本和生成样本的。接下来当我们固定生成模型，而优化判别模型时，优化结果如第二幅图所示，可以看出，这个时候判别模型已经可以较好的区分生成数据和真实数据了。第三步是固定判别模型，改进生成模型，试图让判别模型无法区分生成图片与真实图片，在这个过程中，可以看出由模型生成的图片分布与真实图片分布更加接近，这样的迭代不断进行，直到最终收敛，生成分布和真实分布重合。</p>
<h2 id="理论结果"><a href="#理论结果" class="headerlink" title="理论结果"></a>理论结果</h2><p>迭代足够多的次数后，D与G最后会收敛。<br>如果对给定的G，那么最佳的D是：<br><img src="https://i.loli.net/2019/11/13/re9wyRApGqfCu6j.png" alt="6.png"></p>
<p>证明：<br><img src="https://i.loli.net/2019/11/13/nkRYCy1cMJsmwpX.png" alt="7.png"><br>数据给定，G 给定时，$P_{data}$和$P_g$都可以看作常数，令$P_{data}$ 为a，令$P_g$为b。则有：<br><img src="https://i.loli.net/2019/11/13/QLr7HKN9kxRUSfa.png" alt="8.png"></p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://i.loli.net/2019/11/13/Mi64s7f9W1CSVOg.png" alt="9.png"><br>最右边的列显示了邻近样本的最近训练示例。因为采样过程不依赖于马尔可夫链（t+1时刻系统状态的概率分布只与t时刻的状态有关，与t时刻以前的状态无关），所以这些样本是不相关的。</p>
<h2 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h2><ul>
<li>D 和G 训练同步的问题。</li>
<li>没有损失函数，在训练过程中很难区分是否正在取得进展，学习过程可能发生崩溃问题（生成器开始退化，总是生成同样的样本点，无法继续学习。当生成模型崩溃时，判别模型也会对相似的样本点指向相似的方向，训练无法继续。）。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是这几年大火的GAN的开山之作《Generative Adversarial Nets》的一些阅读总结&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.chenwe.top/categories/Machine-Learning/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>R-CNN简析</title>
    <link href="http://blog.chenwe.top/2019/10/27/2019/2019-10-27%20R-CNN%E7%AE%80%E6%9E%90/"/>
    <id>http://blog.chenwe.top/2019/10/27/2019/2019-10-27 R-CNN简析/</id>
    <published>2019-10-27T11:29:34.220Z</published>
    <updated>2019-10-27T12:16:22.104Z</updated>
    
    <content type="html"><![CDATA[<p>本文是RCNN的经典论文《Rich feature hierarchies for accurate oject detection and semantic segmentation》的一些阅读总结<br>这篇论文是在2012年的CNN论文基础上，增加了物体检测的RCNN开山之作，在它后续还有FastRCNN 和 FasterRCNN</p>
<a id="more"></a>
<p><a href="https://arxiv.org/pdf/1311.2524.pdf" target="_blank" rel="external"><strong>论文阅读地址</strong></a></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>作者提出了一种简单并且可扩展的检测算法，可以在VOC2012（一个图像识别challenge主要目的是识别真实场景中一些类别的物体）最好结果的基础上提高30%以上——达到了53.3%。他们的方法结合了两个关键的因素：在候选区域上自下而上使用大型卷积神经网络(CNNs)，用以定位和分割物体。当带标签的训练数据不足时，先针对辅助任务进行有监督预训练，再进行特定任务的调优，就可以产生明显的性能提升。他们把region proposal和CNNs结合起来，所以该方法被称为R-CNN：Regions with CNN features。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>当2012年CNN在图像识别大赛上取得巨大成功后，人们开始把注意力转向了如何将CNN分类结果应用到物体检测任务上。作者通过连接图像分类和目标检测，回答了这个问题。作者主要关注了两个问题：使用深度网络定位物体和在小规模的标注数据集上进行大型网络模型的训练。图像检测需要定位一个图像内的许多物体，传统的方法是将它看成回归问题，但是效果并不好。另一个方法是使用滑动窗口探测器，但是随着网络层次的加深，滑动窗口使用变得困难。作者的方法是通过操作”recognition using regions”范式，解决了CNN的定位问题。在作者测试时，对每一张图片图片，产生近2000个与类别无关的region proposal，对每个CNN抽取一个固定长度的特征向量，然后借助专门针对特定类别数据的线性SVM对每个区域进行分类。使用放射图像变形的方法来对每个不同形状的region proposal产生一个固定长度的作为CNN输入的特征向量（也就是把不同大小的proposal放到同一个大小）。整个流程入下图<br><img src="https://i.loli.net/2019/10/27/BbmPjwqSdxHK9rc.png" alt="QQ截图20191023213328.png"><br>第二个挑战是标签数据太少，可用的数据不能够用来训练大型卷积网络。传统方法多是采用无监督与训练，再进行有监督调优。本文的第二个核心贡献是在辅助数据集（ILSVRC）上进行有监督预训练，再在小数据集上针对特定问题进行调优。除此之外，作者还发现如果将CNN隔开，移除掉其中94%的参数，精度只会下降一点点。但如果通过探测单元，可以发现卷积层学习了丰富的特性如下图：<br><img src="https://i.loli.net/2019/10/27/MKRtYfAZCTgUVie.png" alt="QQ截图20191027201351.png"><br>这说明在网络中，对识别起主要作用的是卷积层。</p>
<h2 id="系统模块"><a href="#系统模块" class="headerlink" title="系统模块"></a>系统模块</h2><p>物体检测系统有三个模块构成。第一个，产生类别无关的region proposal。第二个是一个大型卷积神经网络，用于从每个区域抽取特定大小的特征向量；第三个是一个用于分类的线性SVM。</p>
<h2 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h2><p>对每个推荐区域抽取一个4096维度的特征向量把一个输入为277*277大小的图片，通过五个卷积层和两个全连接层进行前向传播,最终得到一个4096-D的特征向量。网络的细节可以参考AlexNet。但作者在对图像进行转换时用了不同于AlexNet的方法（原方法是缩放后裁剪），作者是在图片变形之前，在候选框周围加上16像素的padding，再进行各向异形缩放。</p>
<h2 id="测试阶段的物体检测"><a href="#测试阶段的物体检测" class="headerlink" title="测试阶段的物体检测"></a>测试阶段的物体检测</h2><p>抽取2000个推荐区域。然后变形每一个推荐区域，再通过CNN前向传播计算出特征。然后我们使用对每个类别训练出的SVM给整个特征向量中的每个类别单独打分。然后给出一张图像中所有的打分区域，然后使用NMS，拒绝掉一些和高分区域的IOU大于阈值的候选框。<br>NMS是非极大值抑制，即不是局部的最大值的那些值都去掉。如下图所示，去掉局部的非极大值。</p>
<p><img src="https://i.loli.net/2019/10/27/wGArmyaXDs7b25n.png" alt="QQ截图20191027201539.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是RCNN的经典论文《Rich feature hierarchies for accurate oject detection and semantic segmentation》的一些阅读总结&lt;br&gt;这篇论文是在2012年的CNN论文基础上，增加了物体检测的RCNN开山之作，在它后续还有FastRCNN 和 FasterRCNN&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.chenwe.top/categories/Machine-Learning/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>AlexNet网络简析</title>
    <link href="http://blog.chenwe.top/2019/10/17/2019/2019-10-17%20AlexNet%E7%BD%91%E7%BB%9C%E7%AE%80%E6%9E%90/"/>
    <id>http://blog.chenwe.top/2019/10/17/2019/2019-10-17 AlexNet网络简析/</id>
    <published>2019-10-17T13:47:25.248Z</published>
    <updated>2019-10-17T14:31:34.638Z</updated>
    
    <content type="html"><![CDATA[<p>本文是卷积神经网络的经典论文《ImageNet Classification with Deep Convolutional Neural Networks》的一些阅读总结<br>这篇论文摘得了2010年ILSVRC比赛的桂冠。是剖析 CNN 领域的经典之作，也是入门 CNN 的必读paper。<br>由于采用了深度卷积神经网络后极大的提升了图片识别的准确率，所以从这篇paper后引发了卷积神经网络计算机视觉的浪潮。</p>
<a id="more"></a>
<p><a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="external"><strong>论文阅读地址</strong></a></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>作者训练了一个大型深度卷积神经网络，并取得了当年ImageNet（图像识别目前最大的数据库）的最好成绩。为了训练的更快，作者使用了非饱和神经元（ReLu），同时使用了非常高效的GPU实现。为了减少过拟合，作者还使用了名为Dropout的正则化方法。</p>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>作者在ImageNet上获取的数据集是经过标注的高分辨率图像。ImageNet的训练结果一般报告两个错误top-1和top-5，top-5错误率是指测试图像的正确标签不在模型认为的五个最可能的便签之中。由于数据集包含各种分辨率图像，而作者的系统要求输入特定的维度，所以作者将图像的采样固定到256*256，方法是先将图像最短边缩放到256像素，再从缩放后的图像中心裁剪出256*256的图片。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>5个卷积层和3个全连接层。<br><img src="https://i.loli.net/2019/10/17/ZUko6fVEPwBKpF3.png" alt="QQ截图20191017221754.png"></p>
<h2 id="网络结构的创新点"><a href="#网络结构的创新点" class="headerlink" title="网络结构的创新点"></a>网络结构的创新点</h2><ul>
<li>ReLU<br>传统的神经元的输出激活函数通常采用$f(x)=tanh(x)$或$f(x)=\frac{1}{1+e^{-x}}$ ，是线性函数，作者采用了$ReLU(x)$非线性函数的深度卷积神经网络训练时间比等价的tanh单元要快几倍。<br><img src="https://i.loli.net/2019/10/17/bBCgnI87SQVeNoF.png" alt="QQ截图20191017221953.png"><br>上图从左到右分别是$f(x)=tanh(x)$、$f(x)=\frac{1}{1+e^{-x}}$ 、$ReLU(x)$。</li>
</ul>
<p>下图是论文中使用了ReLU和tanh函数的神经元训练次数与错误率的关系图，可以看到使用了ReLU的用更少的迭代次数就达到了25%的错误率。<br><img src="https://i.loli.net/2019/10/17/EOxs91r5oDHfBF7.png" alt="QQ截图20191017222101.png"></p>
<ul>
<li>Overlapping Pooling(重叠池化)<br>传统的池化窗口大小等于步长大小，所以不会出现重叠。而作者采用了Overlapping Pooling(重叠池化)，相比于正常池化（步长s=2，窗口z=2） 重叠池化(步长s=2，窗口z=3) 可以减少top-1, top-5分别为0.4% 和0.3%。重叠池化可以避免过拟合。</li>
</ul>
<h2 id="减少过拟合"><a href="#减少过拟合" class="headerlink" title="减少过拟合"></a>减少过拟合</h2><p>作者为了减少过拟合，用了以下两个方法。</p>
<ul>
<li>数据增强<br>最简单常用的用来减少过拟合的方法是使用标签保留变换来人工增大数据集。作者采用了水平翻转图像和随机裁剪实现图像增强。水平翻转是将图像左右镜像翻转。随机裁剪是将图像随机裁剪成几个小的图像，论文中是从256*256裁剪为224*224，这也是为什么网络架构图中的初始输入是224。<br>水平翻转：<br><img src="https://i.loli.net/2019/10/17/LkKw3dhv1bXreWu.png" alt="QQ截图20191017222232.png"></li>
</ul>
<p>随机裁剪：<br><img src="https://i.loli.net/2019/10/17/QSVwcTWO7YgfRld.png" alt="QQ截图20191017222257.png"><br>如果没有数据增强，作者会因为严重的过度拟合而无法使用如此庞大的网络。</p>
<ul>
<li>Dropout<br>将许多不同模型的预测结合起来是降低测试误差的一个非常不错的方法，但作者的网络十分庞大，需要话几天来训练，代价太大，所以作者采用了Dropout方法，即每个神经元都有0.5的概率对隐层的神经元输出为0，可以被视为随机将部分神经元丢弃，这样每次训练的输入都会经过不同的网络架构，减少过拟合的可能。如下图所示，每次训练都是不同的结构。<br><img src="https://i.loli.net/2019/10/17/t2IvJlBbY3uNOVX.png" alt="QQ截图20191017222425.png"></li>
</ul>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>在ILSVRC-2010竞赛中最佳结果是top-1 47.1%，top-5 28.2%，作者采用CNN获得的成绩是top-1 37.5% top-5 17.0%，远远好于当时的最佳成绩。<br><img src="https://i.loli.net/2019/10/17/CWFMTqchfQpzvYr.png" alt="QQ截图20191017222525.png"><br><img src="https://i.loli.net/2019/10/17/sWVKgPHdbapeiFu.png" alt="QQ截图20191017222534.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是卷积神经网络的经典论文《ImageNet Classification with Deep Convolutional Neural Networks》的一些阅读总结&lt;br&gt;这篇论文摘得了2010年ILSVRC比赛的桂冠。是剖析 CNN 领域的经典之作，也是入门 CNN 的必读paper。&lt;br&gt;由于采用了深度卷积神经网络后极大的提升了图片识别的准确率，所以从这篇paper后引发了卷积神经网络计算机视觉的浪潮。&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.chenwe.top/categories/Machine-Learning/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>误差逆传播算法</title>
    <link href="http://blog.chenwe.top/2019/09/27/2019/2019-09-27%20%E8%AF%AF%E5%B7%AE%E9%80%86%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.chenwe.top/2019/09/27/2019/2019-09-27 误差逆传播算法/</id>
    <published>2019-09-27T02:17:11.377Z</published>
    <updated>2019-09-28T07:11:52.146Z</updated>
    
    <content type="html"><![CDATA[<p>本文是周志华的《机器学习》第5章5.3部分的误差逆传播算法的公式推导解释<br>本文默认读者已知晓<code>多层前馈网络</code>的知识</p>
<a id="more"></a>
<h1 id="BackPropagation"><a href="#BackPropagation" class="headerlink" title="BackPropagation"></a>BackPropagation</h1><p>BackPropagation 即 误差逆传播算法 也称 反向传播算法。<br>是一种神经网络的学习算法。训练多层网络，简单的感知机规则不够用，需要采用误差逆传播算法进行训练，得到各个连接处的权值。</p>
<h2 id="符号含义"><a href="#符号含义" class="headerlink" title="符号含义"></a>符号含义</h2><p>以下是本文的一些符号含义<br><img src="https://i.loli.net/2019/09/27/JRegOK9S3quYjEI.png" alt="QQ截图20190927132617.png"><br>如图以西瓜书上的图5.7 的神经网络为例子。<br>给定训练集$D={(x_1,y_1),(x_2,y_2),……(x_m,y_m)},x_i \in R^d,y_i \in R^l$<br>如图所示有 $d$ 个输入神经元，$l$ 个输出神经元， $q$ 个隐层神经元。<br>记：</p>
<ul>
<li>输出层第 $j$ 个神经元的阈值用$\theta_j$表示</li>
<li>隐层第 $h$个神经元的阈值用$\gamma_h$表示</li>
<li>输入层第$i$ 个神经元与隐层第$h$个神经元之间的连接权为$v_{ih}$</li>
<li>隐层第$h$个神经元与输出层第$j$个神经元之间的连接权为$w_{hj}$</li>
</ul>
<p>隐层的神经元接受到的输入是输入层$d$个神经元的属性与权重的乘积之和，所以记：</p>
<ul>
<li>隐层第$h$个神经元接收到的输入为$\alpha_h=\sum_{i=1}^dv_{ih}x_i$</li>
</ul>
<p>记$b_n$为隐层第$h$个神经元的输出同理可得：</p>
<ul>
<li>输出层第$j$个神经元接收到的输入为$\beta_j=\sum_{h=1}^qw_{hj}b_h$</li>
</ul>
<p>这里我们假设隐层和输出层的神经元都使用Sigmoid函数：</p>
<script type="math/tex; mode=display">
h_\theta(x) = \frac{1}{1+e^{(-\theta^Tx)}}</script><p>对于训练例子 ($x_k$, $y_k$) ，我们假定神经元输出为$\widehat{y}_k=(\widehat{y}_1^k,\widehat{y}_2^k,……,\widehat{y}_l^k)$，即：</p>
<script type="math/tex; mode=display">
\widehat{y}_j^k=f(\beta_j-\theta_j)       \hspace{2cm}(1)</script><p>因此，该神经网络在 ($x_k$, $y_k$)上的均方误差为:</p>
<script type="math/tex; mode=display">
E_k=\frac{1}{2}\sum_{j=1}^{l}(\widehat{y}_j^k-y_j^k)^2       \hspace{2cm}(2)</script><p>这里的 1/2 是为了等下求导的时候可以抵消掉多余的 2 .</p>
<h2 id="隐层与输出层神经元之间的连接权更新"><a href="#隐层与输出层神经元之间的连接权更新" class="headerlink" title="隐层与输出层神经元之间的连接权更新"></a>隐层与输出层神经元之间的连接权更新</h2><p>BackPropagation算法类似于梯度下降，任意参数$v$的更新式为：</p>
<script type="math/tex; mode=display">
v\leftarrow v+\Delta v     \hspace{2cm}(3)</script><p>我们以目标的负梯度方向对参数进行调整，对于（2）式的误差$E_k$，给定学习率$\eta$,有：</p>
<script type="math/tex; mode=display">
\Delta w_{ij}=-\eta\frac{\partial E_k}{\partial w_{ij}}     \hspace{2cm}(4)</script><p>这里的负号是因为根据式（3）的更新式，我们希望误差$E_k$尽可能的小（即尽可能接近极值，导数为0），当$\frac{\partial E_k}{\partial w_{ij}}&gt;0$时，有$\Delta w_{ij}=-\eta\frac{\partial E_k}{\partial w_{ij}}$小于0，根据（3）式$w$会减小，使得$E_k$也变小。<br>同理可得当$\frac{\partial E_k}{\partial w_{ij}}&lt;0$时，有$\Delta w_{ij}=-\eta\frac{\partial E_k}{\partial w_{ij}}$大于0，根据（3）式$w$会增加，使得$E_k$也变小。</p>
<p>根据神经网络的结构，我们$w_{hj}$先通过影响第$j$个输出层神经元的输入值$\beta_j$，再影响输出值$\widehat{y}_j^k$，最后影响到$E_k$，因此有：</p>
<script type="math/tex; mode=display">
\frac{\partial E_k}{\partial w_{ij}}=\frac{\partial E_k}{\partial \widehat{y}_j^k}.\frac{\partial \widehat{y}_j^k}{\partial \beta_j}. \frac{\partial \beta_j}{\partial w_{ij}}            \hspace{2cm}(5)</script><p>这就是<code>链式法则</code>，是微积分中的求导法则，用于求一个复合函数的导数，是在微积分的求导运算中一种常用的方法。</p>
<p>根据前面$\beta_j$的定义$\beta_j=\sum_{h=1}^qw_{hj}b_h$，将他对$\partial w_{ij}$求偏导<br>可以得到</p>
<script type="math/tex; mode=display">
\frac{\partial \beta_j}{\partial w_{ij}} = b_n  \hspace{2cm}(6)</script><p>同理$E_k=\frac{1}{2}\sum_{j=1}^{l}(\widehat{y}_j^k-y_j^k)^2$对$\widehat{y}_j^k$求偏导可得：</p>
<script type="math/tex; mode=display">
\begin{aligned} \frac{\partial E_k}{\partial \widehat{y}_j^k}&=\frac{1}{2}.2(\widehat{y}_j^k-y_j^k)(1-0) \\ &=(\widehat{y}_j^k-y_j^k)\end{aligned}</script><p>同理将$\widehat{y}_j^k=f(\beta_j-\theta_j)$对$\beta_j$求偏导可得：</p>
<script type="math/tex; mode=display">
\frac{\partial \widehat{y}_j^k}{\partial \beta_j}=f'(\beta_j-\theta_j)</script><p>因为我们这里隐层和输出层神经元都是使用Sigmoid函数，而Sigmoid函数有以下性质：</p>
<script type="math/tex; mode=display">
f'(x)=f(x)(1-f(x))</script><p>因此$\frac{\partial \widehat{y}_j^k}{\partial \beta_j}$可以继续化简为：</p>
<script type="math/tex; mode=display">
\frac{\partial \widehat{y}_j^k}{\partial \beta_j}=\widehat{y}_j^k(1-\widehat{y}_j^k)</script><p>我们令：</p>
<script type="math/tex; mode=display">
\begin{aligned} g_j&=-\frac{\partial E_k}{\partial \widehat{y}_j^k}.\frac{\partial \widehat{y}_j^k}{\partial \beta_j} \\ &=\widehat{y}_j^k(1-\widehat{y}_j^k)(y_j^k-\widehat{y}_j^k) \end{aligned}    \hspace{2cm}(7)</script><p>我们将以上(6)和（7）化简的结果带入（5）式中，得到：</p>
<script type="math/tex; mode=display">
\Delta w_{hj}=\eta g_jb_n</script><p><strong>这就是BackPropagation算法中关于$w_{hj}$的更新公式</strong></p>
<p>同理我们可以对$\theta_j$进行相同的操作。<br>因为$\theta_j$通过影响$\widehat{y}_j^k$来影响$E_k$，所以有：</p>
<script type="math/tex; mode=display">
\Delta\theta_j=-\eta\frac{\partial E_k}{\partial \theta_j}=-\eta.\frac{\partial E_k}{\partial \widehat{y}_j^k}.\frac{\partial \widehat{y}_j^k}{\partial \theta_j}     \hspace{2cm}(8)</script><p>其中:</p>
<script type="math/tex; mode=display">
\frac{\partial E_k}{\partial \widehat{y}_j^k}=(\widehat{y}_j^k-{y}_j^k)</script><p>因为输出层神经元使用的是Sigmoid函数，所以有：</p>
<script type="math/tex; mode=display">
\begin{aligned} \frac{\partial \widehat{y}_j^k}{\partial \theta_j}&=-f'(\beta_j-\theta_j) \\ &=-f(\beta_j-\theta_j)(1-f(\beta_j-\theta_j) \\ &=-\widehat{y}_j^k(1-\widehat{y}_j^k)
\end{aligned}</script><p><strong>因此我们得出$\theta_j$的更新公式：</strong></p>
<script type="math/tex; mode=display">
\Delta \theta_j=-\eta.\frac{\partial E_k}{\partial \theta_j}=-\eta.\frac{\partial E_k}{\partial \widehat{y}_j^k}.\frac{\partial \widehat{y}_j^k}{\partial \theta_j}=-\eta g_j</script><h2 id="输入层与隐层之间连接权更新"><a href="#输入层与隐层之间连接权更新" class="headerlink" title="输入层与隐层之间连接权更新"></a>输入层与隐层之间连接权更新</h2><p>我们可以将上面的计算方法用到输入层和隐层上，但是要注意，因为隐层中的某个神经元连接了$l$个输出层神经元，所以要做一个求和操作。<br>计算后可得:</p>
<script type="math/tex; mode=display">
\Delta v_{ih}=\eta e_hx_i</script><script type="math/tex; mode=display">
\Delta \gamma_h=-\eta e_h</script><p>其中$e_h$如下:</p>
<script type="math/tex; mode=display">
\begin{aligned} e_h&=\frac{\partial E_k}{\partial b_n}.\frac{\partial b_n}{\partial \alpha_n} \\ &=b_n(1-bn)\sum_{j=1}^lw_{hj}g_j
\end{aligned}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是周志华的《机器学习》第5章5.3部分的误差逆传播算法的公式推导解释&lt;br&gt;本文默认读者已知晓&lt;code&gt;多层前馈网络&lt;/code&gt;的知识&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.chenwe.top/categories/Machine-Learning/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Kaggle入门题目Titanic的逻辑回归应用（三）</title>
    <link href="http://blog.chenwe.top/2019/07/29/2019/2019-07-29%20Kaggle%E5%85%A5%E9%97%A8%E9%A2%98%E7%9B%AETitanic%E7%9A%84%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://blog.chenwe.top/2019/07/29/2019/2019-07-29 Kaggle入门题目Titanic的逻辑回归应用（三）/</id>
    <published>2019-07-29T10:53:49.699Z</published>
    <updated>2019-07-31T05:06:35.274Z</updated>
    
    <content type="html"><![CDATA[<p>在上次优化的基础上，在进行一些feature engineering</p>
<a id="more"></a>
<h1 id="利用好Cabin"><a href="#利用好Cabin" class="headerlink" title="利用好Cabin"></a>利用好Cabin</h1><p>之前我们在处理Cabin的时候，我们只是将它是否缺失作为特征，并没有利用Cabin数据里面的内容。<br>我们可以先通过<code>cross_validation_bad_case(df)</code>函数来看下我们做交叉验证时那些预测错误的Cabin有什么信息。(前两篇博客中有提到这个函数)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross_validation_bad_case</span><span class="params">(df)</span>:</span></div><div class="line">    <span class="comment"># .train_test_split将原始数据按照比例分割为“测试集”和“训练集”</span></div><div class="line">    <span class="comment"># train_size：可以为浮点、整数或None，默认为None</span></div><div class="line">    <span class="comment"># ①若为浮点时，表示训练集占总样本的百分比</span></div><div class="line">    <span class="comment"># ②若为整数时，表示训练样本的样本数</span></div><div class="line">    <span class="comment"># ③若为None时，train_size自动被设置成0.75</span></div><div class="line">    <span class="comment"># random_state：随机数的种子。可以为整数、RandomState实例或None，默认为Non</span></div><div class="line">    <span class="comment"># ①若为None时，每次生成的数据都是随机，可能不一样</span></div><div class="line">    <span class="comment"># ②若为整数时，每次生成的数据都相同</span></div><div class="line">    split_train, split_cv = model_selection.train_test_split(df, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>)</div><div class="line">    <span class="comment"># 获取需要的数据</span></div><div class="line">    train_df = split_train.filter(regex=<span class="string">'Survived|Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*'</span>)</div><div class="line">    clf = linear_model.LogisticRegression(solver=<span class="string">'liblinear'</span>, C=<span class="number">1.0</span>, penalty=<span class="string">'l1'</span>, tol=<span class="number">1e-6</span>)</div><div class="line">    <span class="comment"># 拟合训练集数据</span></div><div class="line">    clf.fit(train_df.values[:, <span class="number">1</span>:], train_df.values[:, <span class="number">0</span>])</div><div class="line"></div><div class="line">    <span class="comment"># 交叉验证的测试集</span></div><div class="line">    cv_df = split_cv.filter(regex=<span class="string">'Survived|Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*'</span>)</div><div class="line">    <span class="comment"># 预测测试集的结果</span></div><div class="line">    predictions = clf.predict(cv_df.values[:, <span class="number">1</span>:])</div><div class="line"></div><div class="line">    <span class="comment"># 获取原始数据来比较结果</span></div><div class="line">    origin_data_train = pd.read_csv(<span class="string">"data/train.csv"</span>)</div><div class="line">    <span class="comment"># 获取预测结果与测试集的第一列（Survived值）不同的行，他们的PassengerId在原始train.csv中的乘客信息作为bad_cases</span></div><div class="line">    bad_cases = origin_data_train.loc[</div><div class="line">        origin_data_train[<span class="string">'PassengerId'</span>].isin(split_cv[predictions != cv_df.values[:, <span class="number">0</span>]][<span class="string">'PassengerId'</span>].values)]</div><div class="line">    print(bad_cases.head(<span class="number">10</span>))</div></pre></td></tr></table></figure></p>
<p>控制台打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">     PassengerId  Survived  Pclass  ...      Fare    Cabin  Embarked</div><div class="line">23            24         1       1  ...   35.5000       A6         S</div><div class="line">25            26         1       3  ...   31.3875      NaN         S</div><div class="line">49            50         0       3  ...   17.8000      NaN         S</div><div class="line">55            56         1       1  ...   35.5000      C52         S</div><div class="line">65            66         1       3  ...   15.2458      NaN         C</div><div class="line">78            79         1       2  ...   29.0000      NaN         S</div><div class="line">81            82         1       3  ...    9.5000      NaN         S</div><div class="line">118          119         0       1  ...  247.5208  B58 B60         C</div><div class="line">139          140         0       1  ...   79.2000      B86         C</div><div class="line">165          166         1       3  ...   20.5250      NaN         S</div></pre></td></tr></table></figure></p>
<p>观察Cabin这一列，发现缺失很多，但是结合Survived情况来看，我们发现Cabin中B开头的Survived情况都是0（未获救）,而A和C没有这种情况。<br>而且字母后面的数字和Survived也没有什么联系，所以我们可以猜测，Cabin的首字母与最后的获救情况有关系。<br>所以我们要对它做处理。</p>
<h2 id="处理Cabin"><a href="#处理Cabin" class="headerlink" title="处理Cabin"></a>处理Cabin</h2><p>我们写一个format_cabin来获取Cabin的首字母并作为特征加入到data中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_cabin</span><span class="params">(data)</span>:</span></div><div class="line">    <span class="comment"># 由于Cabin为缺失值的情况python会将它读取为NaN，所以n开头就是缺失值</span></div><div class="line">    cabin_str_array = []</div><div class="line">    <span class="keyword">for</span> cabin <span class="keyword">in</span> data.Cabin:</div><div class="line">        cabin_str = str(cabin)</div><div class="line">        cabin_str = cabin_str[<span class="number">0</span>:<span class="number">1</span>]</div><div class="line">        <span class="comment"># python 数组添加值要调用函数 不能直接赋值</span></div><div class="line">        cabin_str_array.append(cabin_str)</div><div class="line">    data[<span class="string">'Cabin_Str'</span>] = cabin_str_array</div><div class="line">    print(data.head(<span class="number">10</span>))</div><div class="line">    <span class="keyword">return</span> data</div></pre></td></tr></table></figure></p>
<p>控制台打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   PassengerId  Survived  Pclass  ... Cabin Embarked  Cabin_Str</div><div class="line">0            1         0       3  ...   NaN        S          n</div><div class="line">1            2         1       1  ...   C85        C          C</div><div class="line">2            3         1       3  ...   NaN        S          n</div><div class="line">3            4         1       1  ...  C123        S          C</div><div class="line">4            5         0       3  ...   NaN        S          n</div><div class="line">5            6         0       3  ...   NaN        Q          n</div><div class="line">6            7         0       1  ...   E46        S          E</div><div class="line">7            8         0       3  ...   NaN        S          n</div><div class="line">8            9         1       3  ...   NaN        S          n</div><div class="line">9           10         1       2  ...   NaN        C          n</div></pre></td></tr></table></figure></p>
<p>可以看到成功的取出了首字母。<br>然后我们将它像之前那样处理，改成0/1的形式表示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_dummies</span><span class="params">(pd, data)</span>:</span></div><div class="line">    <span class="comment"># dummies_cabin = pd.get_dummies(data['Cabin'], prefix='Cabin')</span></div><div class="line">    dummies_embarked = pd.get_dummies(data[<span class="string">'Embarked'</span>], prefix=<span class="string">'Embarked'</span>)</div><div class="line">    dummies_sex = pd.get_dummies(data[<span class="string">'Sex'</span>], prefix=<span class="string">'Sex'</span>)</div><div class="line">    dummies_pclass = pd.get_dummies(data[<span class="string">'Pclass'</span>], prefix=<span class="string">'Pclass'</span>)</div><div class="line">    dummies_cabin_str = pd.get_dummies(data[<span class="string">'Cabin_Str'</span>], prefix=<span class="string">'Cabin_Str'</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 拼接新的列数据</span></div><div class="line">    df = pd.concat([data, dummies_embarked, dummies_sex, dummies_pclass, dummies_cabin_str], axis=<span class="number">1</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 删除多余的列</span></div><div class="line">    df.drop([<span class="string">'Pclass'</span>, <span class="string">'Name'</span>, <span class="string">'Sex'</span>, <span class="string">'Ticket'</span>, <span class="string">'Cabin'</span>, <span class="string">'Embarked'</span>, <span class="string">'Cabin_Str'</span>], axis=<span class="number">1</span>, inplace=<span class="keyword">True</span>)</div><div class="line">    <span class="comment"># 因为test数据中没有T开头的所以删除train中T开头的</span></div><div class="line">    <span class="keyword">if</span> <span class="string">'Cabin_Str_T'</span> <span class="keyword">in</span> df:</div><div class="line">        df.drop([<span class="string">'Cabin_Str_T'</span>], axis=<span class="number">1</span>, inplace=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> df</div></pre></td></tr></table></figure>
<p>我们可以打印控制台查看，就会发现达到了预期的效果。<br>同样的我们要对test数据做处理，但是这里要注意test中没有T开头的Cabin但是train数据中有，所以在上面的代码里，我们做了处理。<br>删除多余的Cabin_Str_T，防止它出错。</p>
<h2 id="生成结果并提交"><a href="#生成结果并提交" class="headerlink" title="生成结果并提交"></a>生成结果并提交</h2><p>按照以前的方式再次生成结果，先不通过bagging来生成<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 取出需要的列</span></div><div class="line">test = df_test.filter(regex=<span class="string">'Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*'</span>)</div><div class="line">predictions = clf.predict(test)</div><div class="line"><span class="comment"># 得出结果 写入csv文件</span></div><div class="line">result = pd.DataFrame(&#123;<span class="string">'PassengerId'</span>:data_test[<span class="string">'PassengerId'</span>].values, <span class="string">'Survived'</span>:predictions.astype(np.int32)&#125;)</div><div class="line">result.to_csv(<span class="string">"data/logistic_regression_prediction.csv"</span>, index=<span class="keyword">False</span>)</div></pre></td></tr></table></figure></p>
<p>将生成的结果提交的kaggle<br><img src="https://i.loli.net/2019/07/29/5d3eeaedb013c52783.png" alt=""><br>发现比没有做feature engineering分数还要低</p>
<p>我们试着做一次bagging看看结果<br><img src="https://i.loli.net/2019/07/29/5d3eec9c2767d73210.png" alt=""><br>做了bagging之后，分数超过了之前几次的分数，是当前的最高分。</p>
<h1 id="利用好Name"><a href="#利用好Name" class="headerlink" title="利用好Name"></a>利用好Name</h1><p>我们之前对于Name字段的处理是直接删掉，浪费了很多有用的信息。<br>通过观察名字列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">PassengerId	Survived	Pclass	Name</div><div class="line">1	0	3	Braund, Mr. Owen Harris</div><div class="line">2	1	1	Cumings, Mrs. John Bradley (Florence Briggs Thayer)</div><div class="line">3	1	3	Heikkinen, Miss. Laina</div><div class="line">4	1	1	Futrelle, Mrs. Jacques Heath (Lily May Peel)</div><div class="line">5	0	3	Allen, Mr. William Henry</div></pre></td></tr></table></figure></p>
<p>我们发现名字中间的称呼大多都一样，所以我们可以把这个作为一个特征来使用。</p>
<h2 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h2><p>我们发现称呼的边上都是有<code>,</code>和<code>.</code>，所以我们可以用正则表达式来获取这些字符串。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_name_msg</span><span class="params">(data)</span>:</span></div><div class="line">    title = []</div><div class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> data.Name:</div><div class="line">        <span class="comment"># 正则表达式\s代表空格 .要用\来转义</span></div><div class="line">        r = re.findall(<span class="string">r',\s(.*?)\.'</span>, name)[<span class="number">0</span>]</div><div class="line">        <span class="comment"># 因为部分称呼太稀少 且存在train与test数据称呼不匹配的情况 所以稀少的称呼全部统一为other </span></div><div class="line">        <span class="keyword">if</span> r != <span class="string">'Col'</span> <span class="keyword">and</span> r != <span class="string">'Dr'</span> <span class="keyword">and</span> r != <span class="string">'Master'</span> <span class="keyword">and</span> r != <span class="string">'Miss'</span> <span class="keyword">and</span> r != <span class="string">'Mr'</span> <span class="keyword">and</span> r != <span class="string">'Mrs'</span> <span class="keyword">and</span> r != <span class="string">'Ms'</span> <span class="keyword">and</span> r != <span class="string">'Rev'</span>:</div><div class="line">            r = <span class="string">'other'</span></div><div class="line">        title.append(r)</div><div class="line">    <span class="comment"># 统一成0/1的形式    </span></div><div class="line">    dummies_title = pd.get_dummies(title, prefix=<span class="string">'title'</span>)</div><div class="line">    data = pd.concat([data, dummies_title], axis=<span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> data</div></pre></td></tr></table></figure></p>
<p>因为有了上次弄Cabin时的经验，由于Name中的称呼会出现train和test数据不一致的情况，所以我们将他们都定义为other。<br>弄完之后，可以打印下信息查看是否成功处理了数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;</div><div class="line">RangeIndex: 891 entries, 0 to 890</div><div class="line">Data columns (total 21 columns):</div><div class="line">PassengerId     891 non-null int64</div><div class="line">Survived        891 non-null int64</div><div class="line">Pclass          891 non-null int64</div><div class="line">Name            891 non-null object</div><div class="line">Sex             891 non-null object</div><div class="line">Age             714 non-null float64</div><div class="line">SibSp           891 non-null int64</div><div class="line">Parch           891 non-null int64</div><div class="line">Ticket          891 non-null object</div><div class="line">Fare            891 non-null float64</div><div class="line">Cabin           204 non-null object</div><div class="line">Embarked        889 non-null object</div><div class="line">title_Col       891 non-null uint8</div><div class="line">title_Dr        891 non-null uint8</div><div class="line">title_Master    891 non-null uint8</div><div class="line">title_Miss      891 non-null uint8</div><div class="line">title_Mr        891 non-null uint8</div><div class="line">title_Mrs       891 non-null uint8</div><div class="line">title_Ms        891 non-null uint8</div><div class="line">title_Rev       891 non-null uint8</div><div class="line">title_other     891 non-null uint8</div><div class="line">dtypes: float64(2), int64(5), object(5), uint8(9)</div><div class="line">memory usage: 91.4+ KB</div><div class="line">None</div><div class="line">&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;</div><div class="line">RangeIndex: 418 entries, 0 to 417</div><div class="line">Data columns (total 20 columns):</div><div class="line">PassengerId     418 non-null int64</div><div class="line">Pclass          418 non-null int64</div><div class="line">Name            418 non-null object</div><div class="line">Sex             418 non-null object</div><div class="line">Age             332 non-null float64</div><div class="line">SibSp           418 non-null int64</div><div class="line">Parch           418 non-null int64</div><div class="line">Ticket          418 non-null object</div><div class="line">Fare            417 non-null float64</div><div class="line">Cabin           91 non-null object</div><div class="line">Embarked        418 non-null object</div><div class="line">title_Col       418 non-null uint8</div><div class="line">title_Dr        418 non-null uint8</div><div class="line">title_Master    418 non-null uint8</div><div class="line">title_Miss      418 non-null uint8</div><div class="line">title_Mr        418 non-null uint8</div><div class="line">title_Mrs       418 non-null uint8</div><div class="line">title_Ms        418 non-null uint8</div><div class="line">title_Rev       418 non-null uint8</div><div class="line">title_other     418 non-null uint8</div><div class="line">dtypes: float64(2), int64(4), object(5), uint8(9)</div></pre></td></tr></table></figure></p>
<p>我们可以看到，train与test中除了Survived字段不同外，其他字段完全相同，这样就可以把数据应用到模型中了。</p>
<h2 id="生成结果"><a href="#生成结果" class="headerlink" title="生成结果"></a>生成结果</h2><p>利用数据生成预测的结果，这里的化用不用bagging都可以，我测试后发现正确率都差不多。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 取出需要的列</span></div><div class="line">test = df_test.filter(regex=<span class="string">'Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*|title_.*'</span>)</div><div class="line">predictions = clf.predict(test)</div><div class="line"><span class="comment"># 得出结果 写入csv文件</span></div><div class="line">result = pd.DataFrame(&#123;<span class="string">'PassengerId'</span>:data_test[<span class="string">'PassengerId'</span>].values, <span class="string">'Survived'</span>:predictions.astype(np.int32)&#125;)</div><div class="line">result.to_csv(<span class="string">"data/logistic_regression_prediction.csv"</span>, index=<span class="keyword">False</span>)</div></pre></td></tr></table></figure></p>
<p>只需要在正则里添加一个<code>|title_.*</code>就行了。<br>生成结果后我们提交到kaggle上<br><img src="https://i.loli.net/2019/07/30/5d4045f795bb430460.png" alt=""><br>发现他的结果比之前的最高分要搞了0.0096左右，算是很大的进步了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次做了两个feature engineering，对于最后结果的提升还是有的，在数据中应该还有一些feature等待我们去发掘，以后再讲把。</p>
<blockquote>
<p><a href="https://blog.csdn.net/han_xiaoyang/article/details/49797143" target="_blank" rel="external">参考博客</a><br>自己对其中的一些代码做了注释方便理解。<br>自己的代码已经上传到了github，欢迎查看<a href="https://github.com/xiaoshidefeng/MachineLearning/tree/master/kaggle/Titanic" target="_blank" rel="external">kaggle Titanic</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上次优化的基础上，在进行一些feature engineering&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.chenwe.top/categories/Machine-Learning/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
      <category term="kaggle" scheme="http://blog.chenwe.top/tags/kaggle/"/>
    
  </entry>
  
  <entry>
    <title>CCF YOCSEF杭州总结</title>
    <link href="http://blog.chenwe.top/2019/07/22/2019/2019-07-22%20CCF%20YOCSEF%E6%9D%AD%E5%B7%9E%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.chenwe.top/2019/07/22/2019/2019-07-22 CCF YOCSEF杭州总结/</id>
    <published>2019-07-22T03:05:12.025Z</published>
    <updated>2019-07-29T15:45:02.152Z</updated>
    
    <content type="html"><![CDATA[<p>昨天参加了CCF YOCSEF杭州，硬核技术系列论坛之人工智能，这里做下一些记录和总结。</p>
<a id="more"></a>
<h1 id="论坛一：深度学习能否继续引爆人工智能？"><a href="#论坛一：深度学习能否继续引爆人工智能？" class="headerlink" title="论坛一：深度学习能否继续引爆人工智能？"></a>论坛一：深度学习能否继续引爆人工智能？</h1><p>这是第一个论坛。主要讨论的是在深度学习火爆的今天，存在着很多质疑的声音，深度学习能否继续引爆人工智能成为整个行业关注的焦点问题。<br>上午的第一个论坛，主要由北大，浙大，北交，上交的教授做了talk，题目是：</p>
<ul>
<li>AI热潮下的冷思索：我们应该研究什么？</li>
<li>视觉结构学习理论和应用</li>
<li>深度学习解释性：从“能”到“不能”</li>
<li>Learning Deep Regression Model for Visual Tracking</li>
</ul>
<p>因为内容过多，所以我选取几个我印象较深的话题来记录。</p>
<h2 id="当下的AI遇到的一些问题"><a href="#当下的AI遇到的一些问题" class="headerlink" title="当下的AI遇到的一些问题"></a>当下的AI遇到的一些问题</h2><p>这块主要是北大的教授讲的，目前AI领域的学术论文投稿呈现爆炸式增长，在AI火爆的同时也暴露出了很多的问题，比如论文数太多，找不到那么多的审稿人，我们需要把期刊建设好。<br>同时近两年来，质疑AI的声音也开始出现，例如Yann LeCun 和Gary Marcus关于就 AI 是否需要类似人类和动物的内置的认知机制，以实现类似人类的智能这一问题，展开了激烈的辩论。<br>教授对于国内的一些创新问题也发表了看法。国外的DeepMind公司近两年来取得很大的创新与成功，但国内的公司却浮躁，总是用一些花式的组合去解决问题，而忽略了创新，总是不计算力的去改进问题，而忽略了本质的创新，AI成了算力的竞争。<br>第一个talk是田教授讲的，主要是一个比较笼统的概括性talk，同时也能让人引起一些思考。比如我们在AI火爆的今天，不要太过浮躁，要脚踏实地的去创新，而不是简单的去通过算力追求什么排行榜的第一名。同时要认真对待论文，不要灌水论文。<br>因为上午大多是深度学习相关的内容，以为本身这方面只是储备还是不够，所以目前对于上午的内容，可能理解还不够深刻。</p>
<h1 id="论坛二：人工智能安全发展之路"><a href="#论坛二：人工智能安全发展之路" class="headerlink" title="论坛二：人工智能安全发展之路"></a>论坛二：人工智能安全发展之路</h1><p>这是下午的第二个论坛，主要针对人工智能安全发展之路，围绕人工智能与安全的关系，如何用安全技术促进人工智能等问题展开讨论。<br>下午talk题目是：</p>
<ul>
<li>智能化漏洞攻防探索</li>
<li>Machine Learning for Inclusive Finance</li>
<li>Deep Learning System Security</li>
<li>eNASA电商风控图算法平台</li>
<li>基于代码属性图及注意力神经网络的漏洞挖掘方法</li>
<li>从AI安全检测到安全AI</li>
<li>系统安全智能化的理论研究与技术实践</li>
</ul>
<h2 id="AI攻防"><a href="#AI攻防" class="headerlink" title="AI攻防"></a>AI攻防</h2><p>目前的网络攻防主要是机器辅助攻防，辅助攻防的现状如下：</p>
<ul>
<li>攻击：需要数天时间挖掘漏洞、编写漏洞利用。</li>
<li>防御：需要数月时间部署安全补丁，攻击时间窗口大。<br>但机器辅助攻防面临很多的挑战</li>
<li>繁琐，易出错</li>
<li>需要经验、创造力</li>
<li>不容易学习，不容易传承</li>
</ul>
<p>所以目前的攻防已经开始从AI辅助攻防逐渐过渡到自动化攻防，自动化攻防的火热也催生了很多的比赛比如CGC（机器自动化攻防超级挑战赛）也就是就是人机大战，目前人和机器特点如下：<br>人类技巧</p>
<ul>
<li>重用其他队伍的补丁（风险：后门）</li>
<li>重放其他队伍的攻击<br>机器优势</li>
<li>免疫简单代码混淆</li>
<li>快速发现漏洞、尝试经典攻击方式<br>目前还有正在探索中的智能化攻防。<br>比如VDiscover是一种用于训练漏洞检测预测器的工具。给出了漏洞发现程序和足够数量的训练过多的training，它提取了轻量级的特征来预测哪些sql查询可能是脆弱的。</li>
</ul>
<h2 id="数据投毒"><a href="#数据投毒" class="headerlink" title="数据投毒"></a>数据投毒</h2><p>数据投毒也越来越引起人们的注意。针对人工智能“数据投毒”有以下两种方式：第一种攻击模式是采用“模型倾斜”的方式，主要攻击目标是人工智能的学习训练的数据样本。二种攻击模式是采取反馈武器化的方式，主要攻击目标是人工智能的学习模型本身。<br>现代深度网络是非常容易受到对抗样本的攻击的。这些对抗样本仅有很轻微的扰动，以至于人类视觉系统无法察觉这种扰动（图片看起来几乎一样）。如图所示：<br><img src="https://i.loli.net/2019/07/23/5d36792c4c96780431.jpeg" alt=""><br>黑客可以通过向真实样本中添加人眼不可见的噪声，导致深度学习模型发生预测错误的样本。<br>目前，在对抗攻击防御上存在三个主要方向：</p>
<p>1）在学习过程中修改训练过程或者修改的输入样本。<br>通过不断输入新类型的对抗样本并执行对抗训练，从而不断提升网络的鲁棒性。</p>
<p>2）修改网络，比如：添加更多层/子网络、改变损失/激活函数等。</p>
<p>3）当分类未见过的样本时，用外部模型作为附加网络。<br>有人提出了一种防御框架，该框架将额外的预输入层附加到目标网络中，并训练它们对对抗样本进行校正，使分类器对同一图像的干净版本的预测与对抗样本预测相同。</p>
<h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><p>漏洞挖掘的技术发展从上世纪70年代的<code>符号执行</code>（系统性的探索程序执行路径），到后来的撒谎给你实际80年代的<code>规则检查</code>（检测程序是否满足编程安全规则），再到后来<code>数据流分析</code>(通过分析程序状态在控制流中的传播来计算静态程序点在运行时的状态)，再到后来的<code>模糊测试</code>（是一种通过向目标系统提供非预期的输入并监视异常结果来发现软件漏洞的方法），再到02年的<code>模型检测</code>（利用工具将程序结构抽象为状态机并对其进行遍历来检测漏洞），漏洞挖掘技术已经反正了很多。<br>但随着软件规模的扩大，传统的漏洞挖掘方法已经效率不高了。所以现在将漏洞挖掘与深度学习结合起来，利用深度学习技术，搭建神经网络模型，研究并实现一种基于深度学习的静态漏洞检测方法。<br>它的整体框架如下：</p>
<ol>
<li>输入源代码</li>
<li>生成代码属性属性图（抽象语法树与控制流图和程序依赖图的联合数据结构）</li>
<li>生成特征张量</li>
<li>神经网络训练与预测</li>
<li>输出预测结果</li>
</ol>
<h2 id="恶意代码检测"><a href="#恶意代码检测" class="headerlink" title="恶意代码检测"></a>恶意代码检测</h2><p>由于Android应用市场的缺乏监管、Android应用开发、部署模式以及Permission权限粒度过粗等问题导致Android应用存在大量的安<br>全问题。恶意应用自动检测和分类技术主要分为2种基本类型:静态检测技术通过逆向分析获得 APK样本源代码进而从中识别恶意代码,检测恶意行为。动态检测技术通过在受控环境中部署和运行APK样本监控其运行状态进而识别恶意行为发现恶意应用。</p>
<h2 id="evasion-attack（逃逸攻击）"><a href="#evasion-attack（逃逸攻击）" class="headerlink" title="evasion attack（逃逸攻击）"></a>evasion attack（逃逸攻击）</h2><p>逃逸是指攻击者在不改变目标机器学习系统的情况下，通过构造特定输入样本以完成欺骗目标系统的攻击。攻击者可以修改一个恶意软件样本的非关键特征，使得它被一个反病毒系统判定为良性样本，从而绕过检测。<br><img src="http://blogs.360.cn/wp-content/uploads/2017/10/1-2.png" alt=""></p>
<h2 id="NLP与安全"><a href="#NLP与安全" class="headerlink" title="NLP与安全"></a>NLP与安全</h2><p>NLP对于安全的应用主要有三点：</p>
<ol>
<li>安全信息抽取分析</li>
<li>代码语义辅助推断</li>
<li>自主编程<br>同时随着智能语音理解成为接受人类命令的常用方式，也出现了安全的问题。<br>传统的攻击需要入侵到汽车系统或者机器人的系统。<br>但是人工智能的攻击只需要突破语音逆向识别技术和传播技术。例如在自动驾驶的汽车上黑客只需播放一段音乐就能控制汽车系统。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天参加了CCF YOCSEF杭州，硬核技术系列论坛之人工智能，这里做下一些记录和总结。&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.chenwe.top/categories/Machine-Learning/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
      <category term="life" scheme="http://blog.chenwe.top/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Kaggle入门题目Titanic的逻辑回归应用（二）</title>
    <link href="http://blog.chenwe.top/2019/07/14/2019/2019-07-13%20Kaggle%E5%85%A5%E9%97%A8%E9%A2%98%E7%9B%AETitanic%E7%9A%84%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://blog.chenwe.top/2019/07/14/2019/2019-07-13 Kaggle入门题目Titanic的逻辑回归应用（二）/</id>
    <published>2019-07-14T02:33:42.415Z</published>
    <updated>2019-07-29T13:57:32.981Z</updated>
    
    <content type="html"><![CDATA[<p>上次只是做了一个简单的baseline model，这次要对它进行优化。</p>
<a id="more"></a>
<h2 id="模型系数关联分析"><a href="#模型系数关联分析" class="headerlink" title="模型系数关联分析"></a>模型系数关联分析</h2><p><strong>LR(Logistic Regression)模型系数</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pd.DataFrame(&#123;<span class="string">"columns"</span>:list(train_df.columns)[<span class="number">1</span>:], <span class="string">"coef"</span>:list(clf.coef_.T)&#125;)</div></pre></td></tr></table></figure></p>
<p>控制台打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">        columns                    coef</div><div class="line">0         SibSp   [-0.3442357317718681]</div><div class="line">1         Parch  [-0.10491618505943567]</div><div class="line">2      Cabin_No                   [0.0]</div><div class="line">3     Cabin_Yes    [0.9021083412078814]</div><div class="line">4    Embarked_C                   [0.0]</div><div class="line">5    Embarked_Q                   [0.0]</div><div class="line">6    Embarked_S  [-0.41726264140407926]</div><div class="line">7    Sex_female    [1.9565693984398733]</div><div class="line">8      Sex_male   [-0.6774218015181127]</div><div class="line">9      Pclass_1    [0.3411592951610138]</div><div class="line">10     Pclass_2                   [0.0]</div><div class="line">11     Pclass_3    [-1.194129274577135]</div><div class="line">12   Age_scaled   [-0.5237664629125204]</div><div class="line">13  Fare_scaled   [0.08443518884050043]</div></pre></td></tr></table></figure></p>
<p>coef_.T是Logistic回归模型中的θ<br>Logistic回归模型如下：</p>
<script type="math/tex; mode=display">
h_\theta(x) = \frac{1}{1+e^{(-\theta^Tx)}}</script><p>其中 θ 是模型参数，其实 θTx 就是一个线性表达式，将这个表达式的结果再一次利用 Logistic 函数映射到 0~1 之间。<br>这些系数为正的特征，和最后结果是一个正相关，反之为负相关。</p>
<h2 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h2><p>接下去我们要优化我们的方法，但是我们不知道最终结果里的那些Survived的真实情况，所以不好评估我们的方法，这里我们就要用到交叉验证了（cross validation）。把train.csv分成两部分，一部分用于训练我们需要的模型，另外一部分数据上看我们预测算法的效果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</div><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> model_selection</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross_validation</span><span class="params">(df)</span>:</span></div><div class="line">    clf = linear_model.LogisticRegression(solver=<span class="string">'liblinear'</span>, C=<span class="number">1.0</span>, penalty=<span class="string">'l1'</span>, tol=<span class="number">1e-6</span>)</div><div class="line">    all_data = df.filter(regex=<span class="string">'Survived|Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*'</span>)</div><div class="line">    X = all_data.values[:, <span class="number">1</span>:]</div><div class="line">    y = all_data.values[:, <span class="number">0</span>]</div><div class="line">    <span class="comment">#</span></div><div class="line">    <span class="comment"># clf估计方法对象(分类器)，这里是LogisticRegression</span></div><div class="line">    <span class="comment"># X：数据特征(Features)</span></div><div class="line">    <span class="comment"># y：数据标签(Labels)</span></div><div class="line">    <span class="comment"># cv代表几折交叉验证 这里是5折，将数据集平均分割成5个等份</span></div><div class="line">    print(model_selection.cross_val_score(clf, X, y, cv=<span class="number">5</span>))</div></pre></td></tr></table></figure></p>
<p>这里用的是5折交叉验证，即数据集平分成5份，使用1份数据作为测试数据，其余作为训练数据。<br>控制台打印：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[0.81564246 0.81564246 0.78651685 0.78651685 0.81355932]</div></pre></td></tr></table></figure></p>
<p>打印的是我们的准确率，相对于kaggle上之前提交的分数要高点，毕竟是不同的数据集，所以会有出入。</p>
<h2 id="获取bad-cases"><a href="#获取bad-cases" class="headerlink" title="获取bad cases"></a>获取bad cases</h2><p>如果只是评分是没有进展的，所以我们需要把那些在交叉验证中预测失败的例子集中取出来分析，看看是不是漏了什么。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross_validation_bad_case</span><span class="params">(df)</span>:</span></div><div class="line">    <span class="comment"># .train_test_split将原始数据按照比例分割为“测试集”和“训练集”</span></div><div class="line">    <span class="comment"># train_size：可以为浮点、整数或None，默认为None</span></div><div class="line">    <span class="comment"># ①若为浮点时，表示训练集占总样本的百分比</span></div><div class="line">    <span class="comment"># ②若为整数时，表示训练样本的样本数</span></div><div class="line">    <span class="comment"># ③若为None时，train_size自动被设置成0.75</span></div><div class="line">    <span class="comment"># random_state：随机数的种子。可以为整数、RandomState实例或None，默认为Non</span></div><div class="line">    <span class="comment"># ①若为None时，每次生成的数据都是随机，可能不一样</span></div><div class="line">    <span class="comment"># ②若为整数时，每次生成的数据都相同</span></div><div class="line">    split_train, split_cv = model_selection.train_test_split(df, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>)</div><div class="line">    <span class="comment"># 获取需要的数据</span></div><div class="line">    train_df = split_train.filter(regex=<span class="string">'Survived|Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*'</span>)</div><div class="line">    clf = linear_model.LogisticRegression(solver=<span class="string">'liblinear'</span>, C=<span class="number">1.0</span>, penalty=<span class="string">'l1'</span>, tol=<span class="number">1e-6</span>)</div><div class="line">    <span class="comment"># 拟合训练集数据</span></div><div class="line">    clf.fit(train_df.values[:, <span class="number">1</span>:], train_df.values[:, <span class="number">0</span>])</div><div class="line"></div><div class="line">    <span class="comment"># 交叉验证的测试集</span></div><div class="line">    cv_df = split_cv.filter(regex=<span class="string">'Survived|Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*'</span>)</div><div class="line">    <span class="comment"># 预测测试集的结果</span></div><div class="line">    predictions = clf.predict(cv_df.values[:, <span class="number">1</span>:])</div><div class="line"></div><div class="line">    <span class="comment"># 获取原始数据来比较结果</span></div><div class="line">    origin_data_train = pd.read_csv(<span class="string">"data/train.csv"</span>)</div><div class="line">    <span class="comment"># 获取预测结果与测试集的第一列（Survived值）不同的行，他们的PassengerId在原始train.csv中的乘客信息作为bad_cases</span></div><div class="line">    bad_cases = origin_data_train.loc[</div><div class="line">        origin_data_train[<span class="string">'PassengerId'</span>].isin(split_cv[predictions != cv_df.values[:, <span class="number">0</span>]][<span class="string">'PassengerId'</span>].values)]</div><div class="line">    print(bad_cases.head(<span class="number">10</span>))</div></pre></td></tr></table></figure></p>
<p>控制台打印：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">     PassengerId  Survived  Pclass  ...      Fare    Cabin  Embarked</div><div class="line">23            24         1       1  ...   35.5000       A6         S</div><div class="line">25            26         1       3  ...   31.3875      NaN         S</div><div class="line">49            50         0       3  ...   17.8000      NaN         S</div><div class="line">55            56         1       1  ...   35.5000      C52         S</div><div class="line">65            66         1       3  ...   15.2458      NaN         C</div><div class="line">78            79         1       2  ...   29.0000      NaN         S</div><div class="line">81            82         1       3  ...    9.5000      NaN         S</div><div class="line">118          119         0       1  ...  247.5208  B58 B60         C</div><div class="line">139          140         0       1  ...   79.2000      B86         C</div><div class="line">165          166         1       3  ...   20.5250      NaN         S</div><div class="line">[10 rows x 12 columns]</div></pre></td></tr></table></figure></p>
<p>这些就是部分的预测有问题的case了，关于代码的解释已经详细的写在注释里了。bad_cases那块代码较长，慢慢理解，不清楚可以搜索关键词<code>python 切片</code>。<br>这里观察这些结果，我们可以试着去猜测一些有用的特征去做Feature engineering（特征工程：的目的就是选择、找到一个更好的Feature为的是predictive models预测模型更加准确。）。例如我们很多特征都没有使用上，比如Name和Cabin。<br>这里的Cabin我们可以猜测某些字母开头的Cabin生存率较低，例如上面这10个数据中，B开头的Cabin都没有幸存，可能B开头的位置不利于逃生。还有很多的地方值得挖掘，但是具体的操作我们还是下次再讲，这次讲下学习完整的流程先。</p>
<h2 id="Learn-Curve学习曲线"><a href="#Learn-Curve学习曲线" class="headerlink" title="Learn Curve学习曲线"></a>Learn Curve学习曲线</h2><p>在我们不断的做Feature engineering的时候，可能会出现过/欠拟合的情况，我们。对于过拟合和欠拟合的优化方式是不同的。<br>对于过拟合，我们通常会选择feature，挑出比较好的feature来训练，或者提供更多的数据弥补原始数据的偏见问题。<br>对于欠拟合，需要用更多的feature来提高模型的准确度。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_learning_curve</span><span class="params">(estimator, title, X, y, ylim=None, cv=None, n_jobs=<span class="number">1</span>,</span></span></div><div class="line">                        train_sizes=np.linspace<span class="params">(<span class="number">.05</span>, <span class="number">1.</span>, <span class="number">20</span>)</span>, verbose=<span class="number">0</span>, plot=True):</div><div class="line">    <span class="string">"""</span></div><div class="line">    画出data在某模型上的learning curve.</div><div class="line">    参数解释</div><div class="line">    ----------</div><div class="line">    estimator : 你用的分类器。</div><div class="line">    title : 表格的标题。</div><div class="line">    X : 输入的feature，numpy类型</div><div class="line">    y : 输入的target vector</div><div class="line">    ylim : tuple格式的(ymin, ymax), 设定图像中纵坐标的最低点和最高点</div><div class="line">    cv : 做cross-validation的时候，数据分成的份数，其中一份作为cv集，其余n-1份作为training(默认为3份)</div><div class="line">    n_jobs : 并行的的任务数(默认1)</div><div class="line">    verbose : 控制冗余。越高，有越多的信息</div><div class="line">    train_size : 控制用于生成学习曲线的样本的绝对或相对数量。是一个数组，</div><div class="line">    例如[0.1,0.25,0.5,1] 就是当样本是总样本数量的10%,25%,…100%时产生learning_curve</div><div class="line">    np.linspace 在指定的间隔内返回均匀间隔的数字，(.05, 1., 20) 是指从5%开始到100%等分为20个</div><div class="line">    """</div><div class="line">    train_sizes, train_scores, test_scores = model_selection.learning_curve(</div><div class="line">        estimator, X, y, cv=cv, n_jobs=n_jobs, train_sizes=train_sizes, verbose=verbose)</div><div class="line"></div><div class="line">    train_scores_mean = np.mean(train_scores, axis=<span class="number">1</span>)</div><div class="line">    train_scores_std = np.std(train_scores, axis=<span class="number">1</span>)</div><div class="line">    test_scores_mean = np.mean(test_scores, axis=<span class="number">1</span>)</div><div class="line">    test_scores_std = np.std(test_scores, axis=<span class="number">1</span>)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> plot:</div><div class="line">        plt.figure()</div><div class="line">        plt.title(title)</div><div class="line">        <span class="keyword">if</span> ylim <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            plt.ylim(*ylim)</div><div class="line">        plt.xlabel(<span class="string">u"训练样本数"</span>)</div><div class="line">        plt.ylabel(<span class="string">u"得分"</span>)</div><div class="line">        plt.gca().invert_yaxis()</div><div class="line">        plt.grid()</div><div class="line"></div><div class="line">        plt.fill_between(train_sizes, train_scores_mean - train_scores_std, train_scores_mean + train_scores_std,</div><div class="line">                         alpha=<span class="number">0.1</span>, color=<span class="string">"b"</span>)</div><div class="line">        plt.fill_between(train_sizes, test_scores_mean - test_scores_std, test_scores_mean + test_scores_std,</div><div class="line">                         alpha=<span class="number">0.1</span>, color=<span class="string">"r"</span>)</div><div class="line">        plt.plot(train_sizes, train_scores_mean, <span class="string">'o-'</span>, color=<span class="string">"b"</span>, label=<span class="string">u"训练集上得分"</span>)</div><div class="line">        plt.plot(train_sizes, test_scores_mean, <span class="string">'o-'</span>, color=<span class="string">"r"</span>, label=<span class="string">u"交叉验证集上得分"</span>)</div><div class="line"></div><div class="line">        plt.legend(loc=<span class="string">"best"</span>)</div><div class="line"></div><div class="line">        plt.draw()</div><div class="line">        plt.gca().invert_yaxis()</div><div class="line">        plt.show()</div><div class="line"></div><div class="line">    midpoint = ((train_scores_mean[<span class="number">-1</span>] + train_scores_std[<span class="number">-1</span>]) + (test_scores_mean[<span class="number">-1</span>] - test_scores_std[<span class="number">-1</span>])) / <span class="number">2</span></div><div class="line">    diff = (train_scores_mean[<span class="number">-1</span>] + train_scores_std[<span class="number">-1</span>]) - (test_scores_mean[<span class="number">-1</span>] - test_scores_std[<span class="number">-1</span>])</div><div class="line">    <span class="keyword">return</span> midpoint, diff</div><div class="line"></div><div class="line"></div><div class="line">plot_learning_curve(clf, <span class="string">u"学习曲线"</span>, X, y)</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/xiaoshidefeng/MachineLearning/blob/master/kaggle/Titanic/image/LearnCurve.png?raw=true" alt=""></p>
<p>从图像判断是否过拟合还是欠拟合，要看训练集和交叉验证集的上下间距，过拟合表现一般是训练集上得分高，而交叉验证集上要低很多，中间的gap比较大。</p>
<h2 id="model-ensemble模型融合"><a href="#model-ensemble模型融合" class="headerlink" title="model ensemble模型融合"></a>model ensemble模型融合</h2><p>model ensemble模型融合是指将不同模型预测的结果综合起来考虑得出一个最大可能的预测结果。<br>例如对于这个问题，我们可以采用不同的分类器（SVM，KNN等），不同的分类器得出不同的预测结果，最后通过投票统计，得出一个最可靠的预测结果。<br>目前我们只用了logistic regression，我们也可以不用全部的训练集去训练模型，每次训练采用不同的subset（子训练集），这样我们可以获得不同的子训练集的训练模型，虽然可能会有部分的模型会有过拟合，但如果最后在全体数据上做一个融合，也会有不错的效果。<br>这就是Bagging。<br>可以用scikit-learn里的Bagging来完成。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bagging</span><span class="params">(df, df_test)</span>:</span></div><div class="line">    train_df = df.filter(regex=<span class="string">'Survived|Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*'</span>)</div><div class="line">    train_np = train_df.values</div><div class="line">    y = train_np[:, <span class="number">0</span>]</div><div class="line">    X = train_np[:, <span class="number">1</span>:]</div><div class="line">    clf = linear_model.LogisticRegression(solver=<span class="string">'liblinear'</span>, C=<span class="number">1.0</span>, penalty=<span class="string">'l1'</span>, tol=<span class="number">1e-6</span>)</div><div class="line">    <span class="comment"># n_estimators要集成的基估计器的个数。</span></div><div class="line">    <span class="comment"># max_samples决定从train抽取去训练基估计器的样本数量。int 代表抽取数量，float代表抽取比例,这里是0.8</span></div><div class="line">    <span class="comment"># max_features 决定从train抽取去训练基估计器的特征数量。int 代表抽取数量，float代表抽取比例，这里是100%</span></div><div class="line">    <span class="comment"># bootstrap 决定样本子集的抽样方式（有放回和不放回），这里是有放回</span></div><div class="line">    <span class="comment"># bootstrap_features决定特征子集的抽样方式（有放回和不放回），这里是不放回</span></div><div class="line">    <span class="comment"># # n_jobs并行job个数 -1 是指与本机核心数相关</span></div><div class="line">    bagging_clf = BaggingRegressor(clf, n_estimators=<span class="number">20</span>, max_samples=<span class="number">0.8</span>, max_features=<span class="number">1.0</span>, bootstrap=<span class="keyword">True</span>,</div><div class="line">                                   bootstrap_features=<span class="keyword">False</span>, n_jobs=<span class="number">-1</span>)</div><div class="line">    <span class="comment"># 拟合</span></div><div class="line">    bagging_clf.fit(X, y)</div><div class="line"></div><div class="line">    <span class="comment"># 取出需要的列</span></div><div class="line">    test = df_test.filter(regex=<span class="string">'Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*'</span>)</div><div class="line">    predictions = bagging_clf.predict(test)</div><div class="line">    <span class="comment"># 得出结果 写入csv文件</span></div><div class="line">    result = pd.DataFrame(&#123;<span class="string">'PassengerId'</span>: data_test[<span class="string">'PassengerId'</span>].values, <span class="string">'Survived'</span>: predictions.astype(np.int32)&#125;)</div><div class="line">    result.to_csv(<span class="string">"data/bagging_logistic_regression_prediction.csv"</span>, index=<span class="keyword">False</span>)</div></pre></td></tr></table></figure></p>
<p>bagging_logistic_regression_prediction.csv<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PassengerId,Survived</div><div class="line">892,0</div><div class="line">893,0</div><div class="line">894,0</div><div class="line">895,0</div><div class="line">896,0</div><div class="line">897,0</div><div class="line">898,1</div><div class="line">899,0</div><div class="line">900,1</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>因为前面没有做新的feature engineering，所这次去提交的话，分时比第一次还要低点。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是对机器学习问题的一个简单流程，从最开始的分析，到后来做一个baseline model，然后在此基础上一步步的分析与提高。<br>下次做一下feature engineering的内容。</p>
<blockquote>
<p><a href="https://blog.csdn.net/han_xiaoyang/article/details/49797143" target="_blank" rel="external">参考博客</a><br>自己对其中的一些代码做了注释方便理解。<br>自己的代码已经上传到了github，欢迎查看<a href="https://github.com/xiaoshidefeng/MachineLearning/tree/master/kaggle/Titanic" target="_blank" rel="external">kaggle Titanic</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次只是做了一个简单的baseline model，这次要对它进行优化。&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.chenwe.top/categories/Machine-Learning/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
      <category term="kaggle" scheme="http://blog.chenwe.top/tags/kaggle/"/>
    
  </entry>
  
  <entry>
    <title>Kaggle入门题目Titanic的逻辑回归应用（一）</title>
    <link href="http://blog.chenwe.top/2019/07/12/2019/2019-07-12%20Kaggle%E5%85%A5%E9%97%A8%E9%A2%98%E7%9B%AETitanic%E7%9A%84%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://blog.chenwe.top/2019/07/12/2019/2019-07-12 Kaggle入门题目Titanic的逻辑回归应用（一）/</id>
    <published>2019-07-12T12:41:57.977Z</published>
    <updated>2019-07-16T05:44:38.606Z</updated>
    
    <content type="html"><![CDATA[<p>Kaggle是一个数据建模和数据分析竞赛平台。企业和研究者可在其上发布数据，统计学者和数据挖掘专家可在其上进行竞赛以产生最好的模型。<br>这次记录一下Kaggle上的入门题目Titanic人员幸存预测，用了逻辑回归。</p>
<a id="more"></a>
<h1 id="比赛题目简析"><a href="#比赛题目简析" class="headerlink" title="比赛题目简析"></a>比赛题目简析</h1><p><a href="https://www.kaggle.com/c/titanic" target="_blank" rel="external">Titanic竞赛地址</a><br><img src="https://i.loli.net/2019/07/16/5d2d62e4eec2566597.jpg" alt=""></p>
<p>在它的Evaluation里的Goal里说明了这个题目的目的：</p>
<blockquote>
<p>It is your job to predict if a passenger survived the sinking of the Titanic or not.<br>For each in the test set, you must predict a 0 or 1 value for the variable.<br>你的工作是预测一名乘客是否能够幸免于泰坦尼克号沉没。<br>对于测试集中的每个，您必须预测变量的0或1值。</p>
</blockquote>
<p>预测幸存与否，其实就是一个二分类问题，可以用logistic regression来处理（当然，方法不止一种）</p>
<p>最后提交的是一个csv格式的文件，其中包含418个条目和一个标题行。<br>该文件应该有两列：<br>PassengerId（按任意顺序排序）<br>Survived（包含你的二元预测：1为幸存，0为死者）</p>
<blockquote>
<p>PassengerId,Survived<br> 892,0<br> 893,1<br> 894,0</p>
</blockquote>
<h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><h2 id="初识数据"><a href="#初识数据" class="headerlink" title="初识数据"></a>初识数据</h2><p>先从Data中下载train.csv与test.csv两个文件<br>按下面的方法导入并查看<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    data_train = pd.read_csv(<span class="string">"data/train.csv"</span>)</div><div class="line">    <span class="comment"># 显示前10个数据</span></div><div class="line">    print(data_train.head(<span class="number">10</span>))</div></pre></td></tr></table></figure></p>
<p>控制台打印结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   PassengerId  Survived  Pclass  ...     Fare Cabin  Embarked</div><div class="line">0            1         0       3  ...   7.2500   NaN         S</div><div class="line">1            2         1       1  ...  71.2833   C85         C</div><div class="line">2            3         1       3  ...   7.9250   NaN         S</div><div class="line">3            4         1       1  ...  53.1000  C123         S</div><div class="line">4            5         0       3  ...   8.0500   NaN         S</div><div class="line">5            6         0       3  ...   8.4583   NaN         Q</div><div class="line">6            7         0       1  ...  51.8625   E46         S</div><div class="line">7            8         0       3  ...  21.0750   NaN         S</div><div class="line">8            9         1       3  ...  11.1333   NaN         S</div><div class="line">9           10         1       2  ...  30.0708   NaN         C</div></pre></td></tr></table></figure></p>
<p>中间的省略号是其他列的数据，显示不下，所以省略<br>可以通过代码更改显示<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 显示所有列</span></div><div class="line">pd.set_option(<span class="string">'display.max_columns'</span>, <span class="keyword">None</span>)</div><div class="line"><span class="comment"># 显示所有行</span></div><div class="line">pd.set_option(<span class="string">'display.max_rows'</span>, <span class="keyword">None</span>)</div><div class="line"><span class="comment"># 设置value的显示长度为100，默认为50</span></div><div class="line">pd.set_option(<span class="string">'max_colwidth'</span>, <span class="number">100</span>)</div></pre></td></tr></table></figure></p>
<p>上面控制台打印的数据是典型的dataframe，可以理解为一个Excel 的表格。</p>
<p>在项目的Data界面中有对字段的说明：</p>
<ul>
<li>PassengerId =&gt; 乘客ID</li>
<li>Pclass =&gt; 乘客等级(1/2/3等舱位)</li>
<li>Name =&gt; 乘客姓名</li>
<li>Sex =&gt; 性别</li>
<li>Age =&gt; 年龄</li>
<li>SibSp =&gt; 堂兄弟/妹个数</li>
<li>Parch =&gt; 父母与小孩个数</li>
<li>Ticket =&gt; 船票信息</li>
<li>Fare =&gt; 票价</li>
<li>Cabin =&gt; 客舱</li>
<li>Embarked =&gt; 登船港口</li>
</ul>
<p>我们通过info()函数来查看数据的总体信息<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(data_train.info())</div></pre></td></tr></table></figure></p>
<p>控制台打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;</div><div class="line">RangeIndex: 891 entries, 0 to 890</div><div class="line">Data columns (total 12 columns):</div><div class="line">PassengerId    891 non-null int64</div><div class="line">Survived       891 non-null int64</div><div class="line">Pclass         891 non-null int64</div><div class="line">Name           891 non-null object</div><div class="line">Sex            891 non-null object</div><div class="line">Age            714 non-null float64</div><div class="line">SibSp          891 non-null int64</div><div class="line">Parch          891 non-null int64</div><div class="line">Ticket         891 non-null object</div><div class="line">Fare           891 non-null float64</div><div class="line">Cabin          204 non-null object</div><div class="line">Embarked       889 non-null object</div><div class="line">dtypes: float64(2), int64(5), object(5)</div><div class="line">memory usage: 83.6+ KB</div><div class="line">None</div></pre></td></tr></table></figure></p>
<p>我们发现Age和Cabin字段有缺失，所以等下要对这两个字段进行处理。</p>
<p>查看整体的描述<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(data_train.describe())</div></pre></td></tr></table></figure></p>
<p>控制台打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">       PassengerId    Survived      Pclass  ...       SibSp       Parch        Fare</div><div class="line">count   891.000000  891.000000  891.000000  ...  891.000000  891.000000  891.000000</div><div class="line">mean    446.000000    0.383838    2.308642  ...    0.523008    0.381594   32.204208</div><div class="line">std     257.353842    0.486592    0.836071  ...    1.102743    0.806057   49.693429</div><div class="line">min       1.000000    0.000000    1.000000  ...    0.000000    0.000000    0.000000</div><div class="line">25%     223.500000    0.000000    2.000000  ...    0.000000    0.000000    7.910400</div><div class="line">50%     446.000000    0.000000    3.000000  ...    0.000000    0.000000   14.454200</div><div class="line">75%     668.500000    1.000000    3.000000  ...    1.000000    0.000000   31.000000</div><div class="line">max     891.000000    1.000000    3.000000  ...    8.000000    6.000000  512.329200</div></pre></td></tr></table></figure></p>
<p>可以看出，总体的生存率大约在0.383838.</p>
<h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>有时候还是图片相对直观点，同时也容易发现一些数据的信息。<br>我们先用pyplot工具画几个图来看看。</p>
<h3 id="乘客的属性分布："><a href="#乘客的属性分布：" class="headerlink" title="乘客的属性分布："></a>乘客的属性分布：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstGraph</span><span class="params">(pd, data_train)</span>:</span></div><div class="line">    fig = plt.figure()</div><div class="line">    <span class="comment"># 设置不透明度0.2</span></div><div class="line">    fig.set(alpha=<span class="number">0.2</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 设置2 * 3的子图区域 第一个图位于（0，0）即第一行第一个列</span></div><div class="line">    plt.subplot2grid((<span class="number">2</span>, <span class="number">3</span>), (<span class="number">0</span>, <span class="number">0</span>))</div><div class="line">    <span class="comment"># 用data_train里的Survived数据作柱形图</span></div><div class="line">    data_train.Survived.value_counts().plot(kind=<span class="string">'bar'</span>)</div><div class="line">    plt.title(<span class="string">u"获救情况（1为获救）"</span>)</div><div class="line">    plt.ylabel(<span class="string">u"人数"</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 第二个图位于第一行第二列</span></div><div class="line">    plt.subplot2grid((<span class="number">2</span>, <span class="number">3</span>), (<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">    data_train.Pclass.value_counts().plot(kind=<span class="string">"bar"</span>)</div><div class="line">    plt.ylabel(<span class="string">u"人数"</span>)</div><div class="line">    plt.title(<span class="string">u"乘客等级分布"</span>)</div><div class="line"></div><div class="line">    plt.subplot2grid((<span class="number">2</span>, <span class="number">3</span>), (<span class="number">0</span>, <span class="number">2</span>))</div><div class="line">    plt.scatter(data_train.Survived, data_train.Age, alpha=<span class="number">0.1</span>)</div><div class="line">    plt.ylabel(<span class="string">u"年龄"</span>)</div><div class="line">    plt.grid(b=<span class="keyword">True</span>, which=<span class="string">'major'</span>, axis=<span class="string">'y'</span>)</div><div class="line">    plt.title(<span class="string">u"按年龄看获救分布（1为获救）"</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 第四个图位于第二行第一列和第二列 colspan=2 是指它的列跨度有两列</span></div><div class="line">    plt.subplot2grid((<span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">0</span>), colspan=<span class="number">2</span>)</div><div class="line">    <span class="comment"># kde是密度图</span></div><div class="line">    data_train.Age[data_train.Pclass == <span class="number">1</span>].plot(kind=<span class="string">'kde'</span>)</div><div class="line">    data_train.Age[data_train.Pclass == <span class="number">2</span>].plot(kind=<span class="string">'kde'</span>)</div><div class="line">    data_train.Age[data_train.Pclass == <span class="number">3</span>].plot(kind=<span class="string">'kde'</span>)</div><div class="line">    plt.xlabel(<span class="string">u"年龄"</span>)</div><div class="line">    plt.ylabel(<span class="string">u"密度"</span>)</div><div class="line">    plt.title(<span class="string">u"各等级的乘客年龄分布"</span>)</div><div class="line">    plt.legend((<span class="string">u"头等舱"</span>, <span class="string">u"二等舱"</span>, <span class="string">u"三等舱"</span>), loc=<span class="string">"best"</span>)</div><div class="line"></div><div class="line">    plt.subplot2grid((<span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">2</span>))</div><div class="line">    data_train.Embarked.value_counts().plot(kind=<span class="string">'bar'</span>)</div><div class="line">    plt.title(<span class="string">u"各登船口岸上岸人数"</span>)</div><div class="line">    plt.ylabel(<span class="string">u"人数"</span>)</div><div class="line"></div><div class="line">    plt.show()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line"></div><div class="line">    data_train = pd.read_csv(<span class="string">"data/train.csv"</span>)</div><div class="line"></div><div class="line">    firstGraph(pd, data_train)</div></pre></td></tr></table></figure>
<p><img src="https://github.com/xiaoshidefeng/MachineLearning/blob/master/kaggle/Titanic/image/AttributeDistribution.png?raw=true" alt=""></p>
<p>图片比表格数据来的直观。观察后发现几个点。3等仓的乘客最多，且年龄大多分布在23岁左右。2等仓的人最少，年龄分布在26左右。一等仓比二等舱多一点，年龄在38岁左右比较多。在S登船口岸上岸的人最多。<br>我们可以考虑这几点：</p>
<ul>
<li>不同的仓位和等级与乘客的财富地位有关，可能会影响最后的获救率。</li>
<li>年龄可能对获救概率有影响</li>
<li>登船口可能也有关系</li>
</ul>
<h3 id="属性与获救结果的统计"><a href="#属性与获救结果的统计" class="headerlink" title="属性与获救结果的统计"></a>属性与获救结果的统计</h3><p><strong>看下不同等级的乘客的获救情况</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">secondGraph</span><span class="params">(pd, data_train)</span>:</span></div><div class="line">    <span class="comment"># 看看各乘客等级的获救情况</span></div><div class="line">    fig = plt.figure()</div><div class="line">    fig.set(alpha=<span class="number">0.2</span>)  <span class="comment"># 设定图表颜色alpha参数</span></div><div class="line"></div><div class="line">    Survived_0 = data_train.Pclass[data_train.Survived == <span class="number">0</span>].value_counts()</div><div class="line">    Survived_1 = data_train.Pclass[data_train.Survived == <span class="number">1</span>].value_counts()</div><div class="line">    df = pd.DataFrame(&#123;<span class="string">u"获救"</span>: Survived_1, <span class="string">u"未获救"</span>: Survived_0&#125;)</div><div class="line">    df.plot(kind=<span class="string">'bar'</span>, stacked=<span class="keyword">True</span>)</div><div class="line">    plt.title(<span class="string">u"各乘客等级的获救情况"</span>)</div><div class="line">    plt.ylabel(<span class="string">u"人数"</span>)</div><div class="line">    plt.xlabel(<span class="string">u"乘客等级"</span>)</div><div class="line">    plt.show()</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/xiaoshidefeng/MachineLearning/blob/master/kaggle/Titanic/image/LevelSurvived.png?raw=true" alt=""><br>可以看出3等仓的获救概率最低，1等仓的获救概率最高，2等仓次之。看来仓位对于最后的获救率有很大的影响。</p>
<p><strong>再来看一下性别与获救情况的关系</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">thirdGraph</span><span class="params">(pd, data_train)</span>:</span></div><div class="line">    fig = plt.figure()</div><div class="line">    fig.set(alpha=<span class="number">0.2</span>)</div><div class="line"></div><div class="line">    Survived_m = data_train.Survived[data_train.Sex == <span class="string">'male'</span>].value_counts()</div><div class="line">    Survived_f = data_train.Survived[data_train.Sex == <span class="string">'female'</span>].value_counts()</div><div class="line">    df = pd.DataFrame(&#123;<span class="string">u"男性"</span>: Survived_m, <span class="string">u"女性"</span>: Survived_f&#125;)</div><div class="line">    df.plot(kind=<span class="string">'bar'</span>, stacked=<span class="keyword">True</span>)</div><div class="line">    plt.title(<span class="string">u"按性别看获救情况"</span>)</div><div class="line">    plt.ylabel(<span class="string">u"人数"</span>)</div><div class="line">    plt.xlabel(<span class="string">u"获救"</span>)</div><div class="line"></div><div class="line">    plt.show()</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/xiaoshidefeng/MachineLearning/blob/master/kaggle/Titanic/image/SexSurvived.png?raw=true" alt=""><br>可以看出女性的获救率高于男性，所以性别也是最后获救率的一个重要特征。</p>
<p><strong>再来看看综合版的</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourthGraph</span><span class="params">(pd, data_train)</span>:</span></div><div class="line">    fig = plt.figure()</div><div class="line">    fig.set(alpha=<span class="number">0.65</span>)</div><div class="line">    plt.title(<span class="string">u"根据舱等级和性别的获救情况"</span>)</div><div class="line"></div><div class="line">    ax1 = fig.add_subplot(<span class="number">141</span>)</div><div class="line">    data_train.Survived[data_train.Sex == <span class="string">'female'</span>][data_train.Pclass != <span class="number">3</span>] \</div><div class="line">        .value_counts().plot(kind=<span class="string">'bar'</span>, label=<span class="string">"female highclass"</span>, color=<span class="string">'#FA2479'</span>)</div><div class="line">    ax1.set_xticklabels([<span class="string">u"获救"</span>, <span class="string">u"未获救"</span>], rotation=<span class="number">0</span>)</div><div class="line">    ax1.legend([<span class="string">u"女性/高级仓"</span>], loc=<span class="string">"best"</span>)</div><div class="line"></div><div class="line">    ax2 = fig.add_subplot(<span class="number">142</span>, sharey=ax1)</div><div class="line">    data_train.Survived[data_train.Sex == <span class="string">'female'</span>][data_train.Pclass == <span class="number">3</span>] \</div><div class="line">        .value_counts().plot(kind=<span class="string">'bar'</span>, label=<span class="string">"famale, low class"</span>, color=<span class="string">'pink'</span>)</div><div class="line">    ax2.set_xticklabels([<span class="string">u"获救"</span>, <span class="string">u"未获救"</span>], rotation=<span class="number">0</span>)</div><div class="line">    ax2.legend([<span class="string">u"女性/低级仓"</span>], loc=<span class="string">"best"</span>)</div><div class="line"></div><div class="line">    ax3 = fig.add_subplot(<span class="number">143</span>, sharey=ax1)</div><div class="line">    data_train.Survived[data_train.Sex == <span class="string">'male'</span>][data_train.Pclass != <span class="number">3</span>] \</div><div class="line">        .value_counts().plot(kind=<span class="string">'bar'</span>, label=<span class="string">"male highclass"</span>, color=<span class="string">"lightblue"</span>)</div><div class="line">    ax3.set_xticklabels([<span class="string">u"获救"</span>, <span class="string">u"未获救"</span>], rotation=<span class="number">0</span>)</div><div class="line">    ax3.legend([<span class="string">u"男性/高级仓"</span>], loc=<span class="string">"best"</span>)</div><div class="line"></div><div class="line">    ax4 = fig.add_subplot(<span class="number">144</span>, sharey=ax1)</div><div class="line">    data_train.Survived[data_train.Sex == <span class="string">"male"</span>][data_train.Pclass == <span class="number">3</span>] \</div><div class="line">        .value_counts().plot(kind=<span class="string">"bar"</span>, label=<span class="string">"male, low class"</span>, color=<span class="string">'steelblue'</span>)</div><div class="line">    ax4.legend([<span class="string">u"男性/低级仓"</span>], loc=<span class="string">"best"</span>)</div><div class="line"></div><div class="line">    plt.show()</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/xiaoshidefeng/MachineLearning/blob/master/kaggle/Titanic/image/TotalSurvived.png?raw=true" alt=""></p>
<p><strong>各登船港口的获救情况</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fifthGraph</span><span class="params">(pd, data_train)</span>:</span></div><div class="line">    fig = plt.figure()</div><div class="line">    fig.set(alpha=<span class="number">0.2</span>)</div><div class="line"></div><div class="line">    Survived_0 = data_train.Embarked[data_train.Survived == <span class="number">0</span>].value_counts()</div><div class="line">    Survived_1 = data_train.Embarked[data_train.Survived == <span class="number">1</span>].value_counts()</div><div class="line">    df = pd.DataFrame(&#123;<span class="string">u'获救'</span>: Survived_1, <span class="string">u'未获救'</span>: Survived_0&#125;)</div><div class="line">    df.plot(kind=<span class="string">'bar'</span>, stacked=<span class="keyword">True</span>)</div><div class="line">    plt.title(<span class="string">u'各港口乘客的获救情况'</span>)</div><div class="line">    plt.xlabel(<span class="string">u'登录港口'</span>)</div><div class="line">    plt.ylabel(<span class="string">u'人数'</span>)</div><div class="line"></div><div class="line">    plt.show()</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/xiaoshidefeng/MachineLearning/blob/master/kaggle/Titanic/image/EmbarkedSurvived.png?raw=true" alt=""></p>
<p><strong>有兄弟姐妹对生存情况的影响</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dataFirst</span><span class="params">(pd, data_train)</span>:</span></div><div class="line">    g = data_train.groupby([<span class="string">'SibSp'</span>, <span class="string">'Survived'</span>])</div><div class="line">    df = pd.DataFrame(g.count()[<span class="string">'PassengerId'</span>])</div><div class="line">    print(df)</div><div class="line"></div><div class="line">    g = data_train.groupby([<span class="string">'Parch'</span>, <span class="string">'Survived'</span>])</div><div class="line">    df = pd.DataFrame(g.count()[<span class="string">'PassengerId'</span>])</div><div class="line">    print(df)</div></pre></td></tr></table></figure></p>
<p>控制台打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">                PassengerId</div><div class="line">SibSp Survived             </div><div class="line">0     0                 398</div><div class="line">      1                 210</div><div class="line">1     0                  97</div><div class="line">      1                 112</div><div class="line">2     0                  15</div><div class="line">      1                  13</div><div class="line">3     0                  12</div><div class="line">      1                   4</div><div class="line">4     0                  15</div><div class="line">      1                   3</div><div class="line">5     0                   5</div><div class="line">8     0                   7</div><div class="line">                PassengerId</div><div class="line">Parch Survived             </div><div class="line">0     0                 445</div><div class="line">      1                 233</div><div class="line">1     0                  53</div><div class="line">      1                  65</div><div class="line">2     0                  40</div><div class="line">      1                  40</div><div class="line">3     0                   2</div><div class="line">      1                   3</div><div class="line">4     0                   4</div><div class="line">5     0                   4</div><div class="line">      1                   1</div><div class="line">6     0                   1</div></pre></td></tr></table></figure></p>
<p>没有太明显的关系</p>
<p><strong>看下Cabin的分布</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(data_train.Cabin.value_counts())</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">G6             4</div><div class="line">B96 B98        4</div><div class="line">C23 C25 C27    4</div><div class="line">D              3</div><div class="line">C22 C26        3</div><div class="line">F33            3</div><div class="line">F2             3</div><div class="line">E101           3</div><div class="line">B28            2</div><div class="line">C125           2</div><div class="line">B49            2</div><div class="line">C78            2</div><div class="line">D17            2</div><div class="line">B18            2</div><div class="line">E67            2</div><div class="line">C2             2</div><div class="line">D20            2</div><div class="line">D26            2</div><div class="line">B5             2</div><div class="line">B77            2</div><div class="line">E44            2</div><div class="line">D33            2</div><div class="line">C65            2</div><div class="line">C123           2</div><div class="line">E25            2</div><div class="line">C124           2</div><div class="line">C68            2</div><div class="line">E24            2</div><div class="line">B35            2</div><div class="line">E121           2</div><div class="line">              ..</div><div class="line">D7             1</div><div class="line">E63            1</div><div class="line">D37            1</div><div class="line">E10            1</div><div class="line">C54            1</div><div class="line">E34            1</div><div class="line">C101           1</div><div class="line">F G63          1</div><div class="line">A14            1</div><div class="line">C45            1</div><div class="line">C46            1</div><div class="line">C32            1</div><div class="line">A32            1</div><div class="line">C91            1</div><div class="line">C99            1</div><div class="line">E49            1</div><div class="line">B73            1</div><div class="line">C110           1</div><div class="line">A24            1</div><div class="line">D15            1</div><div class="line">F38            1</div><div class="line">B37            1</div><div class="line">F E69          1</div><div class="line">B86            1</div><div class="line">B69            1</div><div class="line">E50            1</div><div class="line">E40            1</div><div class="line">C128           1</div><div class="line">E31            1</div><div class="line">E36            1</div><div class="line">Name: Cabin, Length: 147, dtype: int64</div></pre></td></tr></table></figure>
<p>数据太少，且有些数据的意义不明，所以不妨将他处理成有/无Cabin。</p>
<p><strong>有无Cabin与幸存情况的关系</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dataSecond</span><span class="params">(pd, data_train)</span>:</span></div><div class="line">    fig = plt.figure()</div><div class="line">    fig.set(alpha=<span class="number">0.2</span>)</div><div class="line"></div><div class="line">    Survived_cabin = data_train.Survived[pd.notnull(data_train.Cabin)].value_counts()</div><div class="line">    Survived_nocabin = data_train.Survived[pd.isnull(data_train.Cabin)].value_counts()</div><div class="line">    df = pd.DataFrame(&#123;<span class="string">u'有票'</span>: Survived_cabin, <span class="string">u'无票'</span>: Survived_nocabin&#125;).transpose()</div><div class="line">    df.plot(kind=<span class="string">'bar'</span>, stacked=<span class="keyword">True</span>)</div><div class="line">    plt.title(<span class="string">u"按照有无Cabin的获救情况"</span>)</div><div class="line">    plt.ylabel(<span class="string">u'人数'</span>)</div><div class="line">    plt.xlabel(<span class="string">u'Cabin有无'</span>)</div><div class="line"></div><div class="line">    plt.show()</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/xiaoshidefeng/MachineLearning/blob/master/kaggle/Titanic/image/IsCabin.png?raw=true" alt=""><br>可以看出有Cabin相对于没有Cabin的幸存率高一点，所以有无Cabin也可以作为一个特征。</p>
<h2 id="对数据的简单预处理"><a href="#对数据的简单预处理" class="headerlink" title="对数据的简单预处理"></a>对数据的简单预处理</h2><p>接下来要做特征工程(feature engineering)，这个十分重要。对于有缺失的数据，我们要进行处理，就是Age和Cabin。<br>对于Cabin，我们采用是否有数据来处理成yes/no。<br>对于Age，因为缺失的数量不多，所以可以采用决策树算法里的<code>随机森林</code>算法来补充上。<br>这里使用了scikit-learn里面的RandomForest来拟合缺失的年龄数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_missing_age</span><span class="params">(df)</span>:</span></div><div class="line">    <span class="comment"># 把已有的数值型特征取出来丢进Random Forest Regressor中</span></div><div class="line">    age_df = df[[<span class="string">'Age'</span>, <span class="string">'Fare'</span>, <span class="string">'Parch'</span>, <span class="string">'SibSp'</span>, <span class="string">'Pclass'</span>]]</div><div class="line"></div><div class="line">    <span class="comment"># 乘客分成已知年龄和未知年龄两部分</span></div><div class="line">    known_age = age_df[age_df.Age.notnull()].values</div><div class="line">    unknown_age = age_df[age_df.Age.isnull()].values</div><div class="line"></div><div class="line">    <span class="comment"># y即目标年龄</span></div><div class="line">    <span class="comment"># [行,列]</span></div><div class="line">    y = known_age[:, <span class="number">0</span>]</div><div class="line">    <span class="comment"># X即特征属性值</span></div><div class="line">    <span class="comment"># 舍弃第0列（即需要预测的Age那列）</span></div><div class="line">    X = known_age[:, <span class="number">1</span>:]</div><div class="line"></div><div class="line">    <span class="comment"># RandomForestRegressor参数：</span></div><div class="line">    <span class="comment"># n_estimators弱学习器的最大迭代次数大小影响拟合度</span></div><div class="line">    <span class="comment"># n_jobs并行job个数 -1 是指与本机核心数相关</span></div><div class="line">    rfr = RandomForestRegressor(random_state=<span class="number">0</span>, n_estimators=<span class="number">2000</span>, n_jobs=<span class="number">-1</span>)</div><div class="line">    <span class="comment"># 拟合</span></div><div class="line">    rfr.fit(X, y)</div><div class="line"></div><div class="line">    <span class="comment"># [所有行, 舍弃第一列]</span></div><div class="line">    predictedAges = rfr.predict(unknown_age[:, <span class="number">1</span>::])</div><div class="line"></div><div class="line">    <span class="comment"># 将预测的年龄结果 赋值给 数据中Age为空的数据的Age列</span></div><div class="line">    df.loc[(df.Age.isnull()), <span class="string">'Age'</span>] = predictedAges</div><div class="line"></div><div class="line">    <span class="keyword">return</span> df, rfr</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_Cabin_type</span><span class="params">(df)</span>:</span></div><div class="line">    df.loc[(df.Cabin.notnull()), <span class="string">'Cabin'</span>] = <span class="string">'Yes'</span></div><div class="line">    df.loc[(df.Cabin.isnull()), <span class="string">'Cabin'</span>] = <span class="string">'No'</span></div><div class="line">    <span class="keyword">return</span> df</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    data_train = pd.read_csv(<span class="string">"data/train.csv"</span>)</div><div class="line">    data_train, rfr = set_missing_age(data_train)</div><div class="line">    data_train = set_Cabin_type(data_train)</div><div class="line">    print(data_train.head(<span class="number">10</span>))</div></pre></td></tr></table></figure></p>
<p>控制台打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">   PassengerId  Survived  Pclass  ...     Fare Cabin  Embarked</div><div class="line">0            1         0       3  ...   7.2500    No         S</div><div class="line">1            2         1       1  ...  71.2833   Yes         C</div><div class="line">2            3         1       3  ...   7.9250    No         S</div><div class="line">3            4         1       1  ...  53.1000   Yes         S</div><div class="line">4            5         0       3  ...   8.0500    No         S</div><div class="line">5            6         0       3  ...   8.4583    No         Q</div><div class="line">6            7         0       1  ...  51.8625   Yes         S</div><div class="line">7            8         0       3  ...  21.0750    No         S</div><div class="line">8            9         1       3  ...  11.1333    No         S</div><div class="line">9           10         1       2  ...  30.0708    No         C</div><div class="line">[10 rows x 12 columns]</div></pre></td></tr></table></figure></p>
<p>部分数据没有显示出来，但是去查看的话会发现Age被填上了。</p>
<p>接下来要<strong>特征因子化</strong><br>特征因子化就是将特征的值取成0/1，以Sex为例子，属性的值是male和female，我们将Sex属性拆分成Sex_male和Sex_female两个属性，用0/1来表示。Sex_male为0和Sex_female为1表示是女性，反之为男性。<br>我们可以用pandas的”get_dummies”来完成这个工作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_dummies</span><span class="params">(pd, data)</span>:</span></div><div class="line">    dummies_cabin = pd.get_dummies(data[<span class="string">'Cabin'</span>], prefix=<span class="string">'Cabin'</span>)</div><div class="line">    dummies_embarked = pd.get_dummies(data[<span class="string">'Embarked'</span>], prefix=<span class="string">'Embarked'</span>)</div><div class="line">    dummies_sex = pd.get_dummies(data[<span class="string">'Sex'</span>], prefix=<span class="string">'Sex'</span>)</div><div class="line">    dummies_pclass = pd.get_dummies(data[<span class="string">'Pclass'</span>], prefix=<span class="string">'Pclass'</span>)</div><div class="line"></div><div class="line">    df = pd.concat([data, dummies_cabin, dummies_embarked, dummies_sex, dummies_pclass], axis=<span class="number">1</span>)</div><div class="line"></div><div class="line">    df.drop([<span class="string">'Pclass'</span>, <span class="string">'Name'</span>, <span class="string">'Sex'</span>, <span class="string">'Ticket'</span>, <span class="string">'Cabin'</span>, <span class="string">'Embarked'</span>], axis=<span class="number">1</span>, inplace=<span class="keyword">True</span>)</div><div class="line">    <span class="keyword">return</span> df</div></pre></td></tr></table></figure>
<p>控制台打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">   PassengerId  Survived        Age  ...  Pclass_1  Pclass_2  Pclass_3</div><div class="line">0            1         0  22.000000  ...         0         0         1</div><div class="line">1            2         1  38.000000  ...         1         0         0</div><div class="line">2            3         1  26.000000  ...         0         0         1</div><div class="line">3            4         1  35.000000  ...         1         0         0</div><div class="line">4            5         0  35.000000  ...         0         0         1</div><div class="line">5            6         0  23.838953  ...         0         0         1</div><div class="line">6            7         0  54.000000  ...         1         0         0</div><div class="line">7            8         0   2.000000  ...         0         0         1</div><div class="line">8            9         1  27.000000  ...         0         0         1</div><div class="line">9           10         1  14.000000  ...         0         1         0</div><div class="line">[10 rows x 16 columns]</div></pre></td></tr></table></figure></p>
<p>成功的将这些数据转换成了0/1属性。</p>
<p>但是发现Age和Fare属性跨度太大，对之后的拟合会有影响，所以我们要对它进行归一化处理。<br>用scikit-learn里面的preprocessing模块可以实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_preporocessing</span><span class="params">(data)</span>:</span></div><div class="line">    scaler = preprocessing.StandardScaler()</div><div class="line">    age_scale_param = scaler.fit(data[<span class="string">'Age'</span>].values.reshape(<span class="number">-1</span>, <span class="number">1</span>))</div><div class="line">    data[<span class="string">'Age_scaled'</span>] = scaler.fit_transform(data[<span class="string">'Age'</span>].values.reshape(<span class="number">-1</span>, <span class="number">1</span>), age_scale_param)</div><div class="line">    fare_scale_param = scaler.fit(data[<span class="string">'Fare'</span>].values.reshape(<span class="number">-1</span>, <span class="number">1</span>))</div><div class="line">    data[<span class="string">'Fare_scaled'</span>] = scaler.fit_transform(data[<span class="string">'Fare'</span>].values.reshape(<span class="number">-1</span>, <span class="number">1</span>), fare_scale_param)</div><div class="line">    <span class="keyword">return</span> data</div></pre></td></tr></table></figure></p>
<p>控制台打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">   PassengerId  Survived        Age  ...  Pclass_3  Age_scaled  Fare_scaled</div><div class="line">0            1         0  22.000000  ...         1   -0.561380    -0.502445</div><div class="line">1            2         1  38.000000  ...         0    0.613171     0.786845</div><div class="line">2            3         1  26.000000  ...         1   -0.267742    -0.488854</div><div class="line">3            4         1  35.000000  ...         0    0.392942     0.420730</div><div class="line">4            5         0  35.000000  ...         1    0.392942    -0.486337</div><div class="line">5            6         0  23.838953  ...         1   -0.426384    -0.478116</div><div class="line">6            7         0  54.000000  ...         0    1.787722     0.395814</div><div class="line">7            8         0   2.000000  ...         1   -2.029569    -0.224083</div><div class="line">8            9         1  27.000000  ...         1   -0.194333    -0.424256</div><div class="line">9           10         1  14.000000  ...         0   -1.148655    -0.042956</div><div class="line">[10 rows x 18 columns]</div></pre></td></tr></table></figure></p>
<p>看到Age_scaled与Fare_scaled都将Age和Fare转换成了[-1,1]的范围里了。</p>
<h2 id="逻辑回归建模"><a href="#逻辑回归建模" class="headerlink" title="逻辑回归建模"></a>逻辑回归建模</h2><p>使用scikit-learn中的LogisticRegression建模<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">logistic_regression</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># 通过正则拿出需要的那几列</span></div><div class="line">    train_df = df.filter(regex=<span class="string">'Survived|Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*'</span>)</div><div class="line">    train_np = train_df.values</div><div class="line"></div><div class="line">    <span class="comment"># 取出Survived那列 即第一列 作为y</span></div><div class="line">    y = train_np[:, <span class="number">0</span>]</div><div class="line"></div><div class="line">    <span class="comment"># 取出第一列后面的所有列 作为x</span></div><div class="line">    X = train_np[:, <span class="number">1</span>:]</div><div class="line"></div><div class="line">    <span class="comment"># 逻辑回归 正则化选择参数（惩罚项的种类）：</span></div><div class="line">    <span class="comment"># penalty 'l1'or 'l2', default: 'l2' 对应L1的正则化和L2的正则化 影响solver（损失函数优化算法）的选择</span></div><div class="line">    <span class="comment"># l1: solver 只能选liblinear</span></div><div class="line">    <span class="comment"># l2: solver 可选'newton-cg', 'lbfgs', 'liblinear', 'sag'</span></div><div class="line">    <span class="comment"># a) liblinear：使用了开源的liblinear库实现，内部使用了坐标轴下降法来迭代优化损失函数。</span></div><div class="line">    <span class="comment"># b) lbfgs：拟牛顿法的一种，利用损失函数二阶导数矩阵即海森矩阵来迭代优化损失函数。</span></div><div class="line">    <span class="comment"># c) newton-cg：也是牛顿法家族的一种，利用损失函数二阶导数矩阵即海森矩阵来迭代优化损失函数。</span></div><div class="line">    <span class="comment"># d) sag：即随机平均梯度下降，是梯度下降法的变种，和普通梯度下降法的区别是每次迭代仅仅用一部分的样本来计算梯度，</span></div><div class="line"></div><div class="line">    <span class="comment"># C为正则化系数λ的倒数，通常默认为1</span></div><div class="line">    <span class="comment"># tol是迭代终止判据的误差范围</span></div><div class="line">    clf = linear_model.LogisticRegression(solver=<span class="string">'liblinear'</span>, C=<span class="number">1.0</span>, penalty=<span class="string">'l1'</span>, tol=<span class="number">1e-6</span>)</div><div class="line">    clf.fit(X, y)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> clf</div></pre></td></tr></table></figure></p>
<p>控制台打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,</div><div class="line">          intercept_scaling=1, max_iter=100, multi_class=&apos;warn&apos;,</div><div class="line">          n_jobs=None, penalty=&apos;l1&apos;, random_state=None, solver=&apos;liblinear&apos;,</div><div class="line">          tol=1e-06, verbose=0, warm_start=False)</div></pre></td></tr></table></figure></p>
<p>关于LogisticRegression()函数的参数解释与选择我已经注释在代码里了。<br>这样我们就得到了一个model<br>但是我们对于测试数据也要做和train数据之前一样的处理才能应用模型。</p>
<h3 id="处理测试数据的格式"><a href="#处理测试数据的格式" class="headerlink" title="处理测试数据的格式"></a>处理测试数据的格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_test_data</span><span class="params">(data_test)</span>:</span></div><div class="line">    <span class="comment"># 将test文件的格式改成和train一样</span></div><div class="line">    data_test.loc[(data_test.Fare.isnull()), <span class="string">'Fare'</span>] = <span class="number">0</span></div><div class="line">    tmp_df = data_test[[<span class="string">'Age'</span>, <span class="string">'Fare'</span>, <span class="string">'Parch'</span>, <span class="string">'SibSp'</span>, <span class="string">'Pclass'</span>]]</div><div class="line">    null_age = tmp_df[data_test.Age.isnull()].values</div><div class="line"></div><div class="line">    <span class="comment"># 用之前创建号的随机森林的决策树来补充test数据的缺失Age</span></div><div class="line">    X = null_age[:, <span class="number">1</span>:]</div><div class="line">    predictedAge = rfr.predict(X)</div><div class="line">    data_test.loc[(data_test.Age.isnull()), <span class="string">'Age'</span>] = predictedAge</div><div class="line"></div><div class="line">    <span class="comment"># 复用先前的函数</span></div><div class="line">    data_test = set_Cabin_type(data_test)</div><div class="line">    df_test = change_dummies(pd, data_test)</div><div class="line">    df_test = data_preporocessing(df_test)</div><div class="line">    <span class="comment"># print(df_test.head())</span></div><div class="line">    <span class="keyword">return</span> df_test</div></pre></td></tr></table></figure>
<p>控制台打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">   PassengerId   Age  SibSp  Parch  ...  Pclass_2  Pclass_3  Age_scaled  Fare_scaled</div><div class="line">0          892  34.5      0      0  ...         0         1    0.307521    -0.496637</div><div class="line">1          893  47.0      1      0  ...         0         1    1.256241    -0.511497</div><div class="line">2          894  62.0      0      0  ...         1         0    2.394706    -0.463335</div><div class="line">3          895  27.0      0      0  ...         0         1   -0.261711    -0.481704</div><div class="line">4          896  22.0      1      1  ...         0         1   -0.641199    -0.416740</div><div class="line">5          897  14.0      0      0  ...         0         1   -1.248380    -0.471623</div><div class="line">6          898  30.0      0      0  ...         0         1   -0.034018    -0.500221</div><div class="line">7          899  26.0      1      1  ...         1         0   -0.337609    -0.117238</div><div class="line">8          900  18.0      0      0  ...         0         1   -0.944790    -0.507390</div><div class="line">9          901  21.0      2      0  ...         0         1   -0.717097    -0.204154</div><div class="line">[10 rows x 17 columns]</div></pre></td></tr></table></figure></p>
<p>成功将test的数据转换成了train数据之前的格式。</p>
<p>接下去就是应用之前的逻辑回归模型来预测测试数据了。</p>
<h3 id="应用模型"><a href="#应用模型" class="headerlink" title="应用模型"></a>应用模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 取出需要的列</span></div><div class="line">test = df_test.filter(regex=<span class="string">'Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*'</span>)</div><div class="line">predictions = clf.predict(test)</div><div class="line"><span class="comment"># 得出结果 写入csv文件</span></div><div class="line">result = pd.DataFrame(&#123;<span class="string">'PassengerId'</span>:data_test[<span class="string">'PassengerId'</span>].values, <span class="string">'Survived'</span>:predictions.astype(np.int32)&#125;)</div><div class="line">result.to_csv(<span class="string">"data/logistic_regression_prediction.csv"</span>, index=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<p>成功获得<code>logistic_regression_prediction.csv</code>这个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">PassengerId,Survived</div><div class="line">892,0</div><div class="line">893,0</div><div class="line">894,0</div><div class="line">895,0</div><div class="line">896,1</div><div class="line">897,0</div><div class="line">898,1</div><div class="line">899,0</div><div class="line">900,1</div><div class="line">901,0</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>去kaggle上提交这个.csv文件，就可以知道自己的分数与排名了。<br>因为是一个简单的模型，没有做优化，所以分数不会太高。<br><img src="https://i.loli.net/2019/07/16/5d2d6400167cf41879.png" alt=""></p>
<p>接下来就是优化了，下次再讲。</p>
<blockquote>
<p><a href="https://blog.csdn.net/han_xiaoyang/article/details/49797143" target="_blank" rel="external">参考博客</a><br>自己对其中的一些代码做了注释方便理解。<br>自己的代码已经上传到了github，欢迎查看<a href="https://github.com/xiaoshidefeng/MachineLearning/tree/master/kaggle/Titanic" target="_blank" rel="external">kaggle Titanic</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kaggle是一个数据建模和数据分析竞赛平台。企业和研究者可在其上发布数据，统计学者和数据挖掘专家可在其上进行竞赛以产生最好的模型。&lt;br&gt;这次记录一下Kaggle上的入门题目Titanic人员幸存预测，用了逻辑回归。&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.chenwe.top/categories/Machine-Learning/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
      <category term="kaggle" scheme="http://blog.chenwe.top/tags/kaggle/"/>
    
  </entry>
  
  <entry>
    <title>朴素贝叶斯</title>
    <link href="http://blog.chenwe.top/2019/05/19/2019/2019-05-19%20%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    <id>http://blog.chenwe.top/2019/05/19/2019/2019-05-19 朴素贝叶斯/</id>
    <published>2019-05-19T07:25:09.787Z</published>
    <updated>2019-07-12T12:39:00.799Z</updated>
    
    <content type="html"><![CDATA[<p>学习Peter Harrington的《Machine Learning in Action》的一些笔记与个人理解<br>这次是关于朴素贝叶斯算法部分的内容</p>
<a id="more"></a>
<h1 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h1><p><code>P(B|A) = P(A|B) * P(B) / P(A)</code><br>即在已知P(A|B)的情况下如何求得P(B|A)</p>
<h1 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h1><p>基于贝叶斯定理的分类算法一种<br>不同于之前的KNN与决策树的不可变性，朴素贝叶斯的结果是概率的可变的<br>“朴素”是指假设特征之间相互独立 每个特征同等重要。<br>例如一句话中，“美味”这个词后面通常跟着“食物”，所以“美味”和“食物”不是相互独立的，两者之间是有关系的。<br>而“美味”和“跑步”就不太可能出现在同一个句子中，因此这两个是相互独立的。</p>
<p>尽管假设存在一些问题，但朴素贝叶斯实际效果很好。<br>简单来说就是将<code>P(F1F2...Fn|C)P(C)</code> 变为 <code>P(F1|C)P(F2|C) ... P(Fn|C)P(C)</code><br>P(F1|C) 之类的数值是容易通过统计资料得到的</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习Peter Harrington的《Machine Learning in Action》的一些笔记与个人理解&lt;br&gt;这次是关于朴素贝叶斯算法部分的内容&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.chenwe.top/categories/Machine-Learning/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>决策树简析</title>
    <link href="http://blog.chenwe.top/2019/05/18/2019/2019-05-18%20%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%80%E6%9E%90/"/>
    <id>http://blog.chenwe.top/2019/05/18/2019/2019-05-18 决策树简析/</id>
    <published>2019-05-18T08:07:06.669Z</published>
    <updated>2019-05-18T12:30:35.724Z</updated>
    
    <content type="html"><![CDATA[<p>学习Peter Harrington的《Machine Learning in Action》的一些笔记与个人理解<br>这次是关于决策树算法部分的内容</p>
<a id="more"></a>
<h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>决策树在分类问题中表示基于特征对实例进行分类的过程<br>决策树的生成通常包括：特征选择、决策树构建、剪枝三个过程<br>目前有ID3、C4.5、CART三种决策树模型<br>这里简单介绍下ID3的决策树</p>
<h1 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h1><p>ID3主要通过信息增益来进行决策树的抉择划分</p>
<h2 id="熵与信息增益"><a href="#熵与信息增益" class="headerlink" title="熵与信息增益"></a>熵与信息增益</h2><p>熵：表示随机变量的不确定性</p>
<p>条件熵：在一个条件下，随机变量的不确定性</p>
<p>信息增益：熵 - 条件熵</p>
<p>公式如图：<br><img src="https://images2015.cnblogs.com/blog/754644/201609/754644-20160924102146715-235068092.png" alt=""></p>
<p>信息增益就是在划分数据集前后信息发生的变化<br>ID3就是每次根据“最大信息熵增益”选取当前最佳的特征来分割数据（贪心）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习Peter Harrington的《Machine Learning in Action》的一些笔记与个人理解&lt;br&gt;这次是关于决策树算法部分的内容&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.chenwe.top/categories/Machine-Learning/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>KNN算法简析</title>
    <link href="http://blog.chenwe.top/2019/02/28/2019/2019-05-09%20KNN%E7%AE%97%E6%B3%95%E7%AE%80%E6%9E%90/"/>
    <id>http://blog.chenwe.top/2019/02/28/2019/2019-05-09 KNN算法简析/</id>
    <published>2019-02-28T03:33:26.599Z</published>
    <updated>2019-05-11T06:29:58.498Z</updated>
    
    <content type="html"><![CDATA[<p>学习Peter Harrington的《Machine Learning in Action》的一些笔记与个人理解<br>这次是关于KNN算法部分的内容</p>
<a id="more"></a>
<p>Peter Harrington的《Machine Learning in Action》还是挺适合入门的，简单易懂<br>他的第一个机器学习算法就是KNN算法（K-最近邻算法）</p>
<h1 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h1><p>KNN其实就是基于距离来进行分类的算法</p>
<h2 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h2><p>关于不同特征值之间的距离的定义有很多的方法。<br>我们比较常见的有：欧式距离与曼哈顿距离等。<br>欧式距离就是我们中学阶段学过的在几何空间中的两点直线距离。<br>曼哈顿距离是两点间水平距离与纵向距离想家的距离，类似于城市不同街道中的两点距离。</p>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>KNN算法先存在一个样本数据的集合，并且每个样本中每个数据都有自己的标签（知道这个数据的所属类别），这个数据集合就是训练样本集。<br>然后输入没有标签的数据，计算它和所有点之间的距离。然后取出前K个最近的距离的点（KNN的K的由来），统计K个中出现次数最多的分类，那么这个没有标签的数据也作为这个分类。</p>
<h2 id="一些优化"><a href="#一些优化" class="headerlink" title="一些优化"></a>一些优化</h2><p>算法浅显易懂，但还是有很多值得优化的地方。<br>首先，就是计算量较大，如果所有的数都两两比较来计算距离，那将是一笔巨大的开销。<br>所以可以构建KD-TREE来优化。KD-TREE就像一个二叉搜索树，但它是空间化的搜索树，以某一特征值作为一次划分的节点。通过搜索，免去了不必要的点的计算，节省了计算开销。关于KD-TREE的详细介绍，网络上已经有了许多文章，这里不再赘述。</p>
<p>其次，KNN中某些距离的值可能对结果的影响较大。例如部分数据数值较大，差值较大，而一些数据的数值变化较小，数值较小。所以还要采用归一化的方法来合理分类。<br>归一化将数值的取值范围统一到0-1之间，公式为<code>newValue = (oldValue - min) / (max - min)</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习Peter Harrington的《Machine Learning in Action》的一些笔记与个人理解&lt;br&gt;这次是关于KNN算法部分的内容&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.chenwe.top/categories/Machine-Learning/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu交换空间设置</title>
    <link href="http://blog.chenwe.top/2018/05/07/2018/2018-05-07%20Ubuntu%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E8%AE%BE%E7%BD%AE/"/>
    <id>http://blog.chenwe.top/2018/05/07/2018/2018-05-07 Ubuntu交换空间设置/</id>
    <published>2018-05-07T11:41:46.463Z</published>
    <updated>2018-05-07T12:16:08.198Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Swap分区，即交换区，Swap空间的作用可简单描述为：当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap空间中，等到那些程序要运行时，再从Swap中恢复保存的数据到内存中。这样，系统总是在物理内存不够时，才进行Swap交换。</p>
</blockquote>
<p>这次来讲下交换分区的设置</p>
<a id="more"></a>
<h2 id="查看当前的内存情况"><a href="#查看当前的内存情况" class="headerlink" title="查看当前的内存情况"></a>查看当前的内存情况</h2><p>输入 free -m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@iZbp14fsydxm6juwspn5gjZ:~# free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:           2000          84         143           2        1772        1713</div><div class="line">Swap:             0           0           0</div></pre></td></tr></table></figure></p>
<p>我们可以看到，物理内存为2,交换分区为0</p>
<p>所以我们要设置一下</p>
<h2 id="设置交换分区"><a href="#设置交换分区" class="headerlink" title="设置交换分区"></a>设置交换分区</h2><p>我们先去根目录新建一个swap文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root@iZbp14fsydxm6juwspn5gjZ:~# cd ..</div><div class="line">root@iZbp14fsydxm6juwspn5gjZ:/# ls</div><div class="line">bin   dev  home        initrd.img.old  lib64       media  opt   root  sbin  sys  usr  vmlinuz</div><div class="line">boot  etc  initrd.img  lib             lost+found  mnt    proc  run   srv   tmp  var  vmlinuz.old</div><div class="line">root@iZbp14fsydxm6juwspn5gjZ:/# mkdir /swap</div><div class="line">root@iZbp14fsydxm6juwspn5gjZ:/# ls</div><div class="line">bin   etc         initrd.img.old  lost+found  opt   run   swap  usr      vmlinuz.old</div><div class="line">boot  home        lib             media       proc  sbin  sys   var</div><div class="line">dev   initrd.img  lib64           mnt         root  srv   tmp   vmlinuz</div></pre></td></tr></table></figure>
<p>然后进入刚刚建立的swap文件夹里<br><code>cd swap</code></p>
<p>创建一个2G的分区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">root@iZbp14fsydxm6juwspn5gjZ:/swap# dd if=/dev/zero of=swap bs=1M count=2k</div><div class="line">2048+0 records in</div><div class="line">2048+0 records out</div><div class="line">2147483648 bytes (2.1 GB, 2.0 GiB) copied, 18.8597 s, 114 MB/s</div><div class="line">root@iZbp14fsydxm6juwspn5gjZ:/swap# sudo mkswap /swap</div><div class="line">sudo: unable to resolve host iZbp14fsydxm6juwspn5gjZ</div><div class="line">mkswap: warning: truncating swap area to 17179869180 KiB</div><div class="line">mkswap: cannot open /swap: Is a directory</div><div class="line">root@iZbp14fsydxm6juwspn5gjZ:/swap# ls</div><div class="line">swap</div></pre></td></tr></table></figure></p>
<p>创建交换文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@iZbp14fsydxm6juwspn5gjZ:/swap# mkswap swap</div><div class="line">Setting up swapspace version 1, size = 2 GiB (2147479552 bytes)</div><div class="line">no label, UUID=0c2db10b-0f48-41f5-b158-8e2c57f95bc3</div></pre></td></tr></table></figure></p>
<p>挂载交换信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@iZbp14fsydxm6juwspn5gjZ:/swap# swapon swap</div><div class="line">swapon: /swap/swap: insecure permissions 0644, 0600 suggested.</div></pre></td></tr></table></figure></p>
<p>下面再输入 <code>free -m</code> 来查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@iZbp14fsydxm6juwspn5gjZ:/swap# free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:           2000          85          72           2        1842        1713</div><div class="line">Swap:          2047           0        2047</div></pre></td></tr></table></figure>
<p>成功增加2G交换空间</p>
<p><img src="http://ow9eu3p52.bkt.clouddn.com/markdown-img-paste-20180507201314759.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Swap分区，即交换区，Swap空间的作用可简单描述为：当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap空间中，等到那些程序要运行时，再从Swap中恢复保存的数据到内存中。这样，系统总是在物理内存不够时，才进行Swap交换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这次来讲下交换分区的设置&lt;/p&gt;
    
    </summary>
    
      <category term="ubuntu" scheme="http://blog.chenwe.top/categories/ubuntu/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>docker安装owncloud</title>
    <link href="http://blog.chenwe.top/2018/03/25/2018/2018-03-25%20docker%E5%AE%89%E8%A3%85owncloud/"/>
    <id>http://blog.chenwe.top/2018/03/25/2018/2018-03-25 docker安装owncloud/</id>
    <published>2018-03-25T03:28:25.652Z</published>
    <updated>2018-03-25T04:49:01.030Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>ownCloud是一个自由且开源的个人云存储解决方案</p>
</blockquote>
<p>因为偶尔会有文件想要备份或者共享<br>所以就自己搭建了一下ownCloud，这里记录下搭建过程</p>
<a id="more"></a>
<h2 id="安装数据库"><a href="#安装数据库" class="headerlink" title="安装数据库"></a>安装数据库</h2><p>我们要先安装数据库，我这里选择mysql 用docker来安装<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">acm@acm-Lenovo:~/acmcloud$ sudo docker pull registry.docker-cn.com/library/mysql</div><div class="line">Using default tag: latest</div><div class="line">latest: Pulling from library/mysql</div></pre></td></tr></table></figure></p>
<p>这里我用了国内的镜像加速，提高速度。</p>
<p>启动容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=mypassword -d mysql</div></pre></td></tr></table></figure></p>
<p>MYSQL_ROOT_PASSWORD后面填写你要设置的的root密码</p>
<p>输入 sudo docker ps 查看是否成功运行</p>
<h2 id="安装owncloud"><a href="#安装owncloud" class="headerlink" title="安装owncloud"></a>安装owncloud</h2><p>用docker安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">acm@acm-Lenovo:~/acmcloud$ sudo docker pull registry.docker-cn.com/library/owncloud</div><div class="line">Using default tag: latest</div><div class="line">latest: Pulling from library/owncloud</div></pre></td></tr></table></figure></p>
<p>还是利用了国内的镜像加速。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker run -d -p 80:80 owncloud</div></pre></td></tr></table></figure>
<p>启动容器</p>
<p>启动成功后访问服务器ip<br><img src="http://ow9eu3p52.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720180325124304.png" alt=""><br>会看到这样的界面<br>我们填写创建管理员账号密码<br>配置下数据库</p>
<p>这里我们选择mysql数据库，我们创建一个表 名字就叫做owncloud<br>然后填写数据库用户名密码就好了</p>
<p>等待安装完成<br>完成后，我们再次打开页面，就会看到登陆界面了<br>这样我们的云盘就搭好了<br>开始愉快的使用吧</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ownCloud是一个自由且开源的个人云存储解决方案&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为偶尔会有文件想要备份或者共享&lt;br&gt;所以就自己搭建了一下ownCloud，这里记录下搭建过程&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="http://blog.chenwe.top/categories/docker/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>UItimateRecyclerView的使用</title>
    <link href="http://blog.chenwe.top/2018/03/17/2018/2018-03-17%20UItimateRecyclerView%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.chenwe.top/2018/03/17/2018/2018-03-17 UItimateRecyclerView的使用/</id>
    <published>2018-03-17T07:37:29.241Z</published>
    <updated>2018-03-19T06:18:38.813Z</updated>
    
    <content type="html"><![CDATA[<p>如果说项目里有用到RecyclerView的话<br>那么UItimateRecyclerView的使用能让你更加轻松的完成你想要的功能</p>
<a id="more"></a>
<h2 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h2><blockquote>
<p>UltimateRecyclerView是一个RecyclerView（高级和灵活版本的ListView），带有拉动刷新，加载更多，滑动解散，拖放和动画，粘滞标题，滚动显示或隐藏工具栏和FAB等许多功能。您可以使用它just like RecyclerView。</p>
</blockquote>
<h2 id="框架特性"><a href="#框架特性" class="headerlink" title="框架特性"></a>框架特性</h2><ul>
<li>多种动画</li>
<li>滑动即可解散</li>
<li>视差或正常的头部视图</li>
<li>拖放项目</li>
</ul>
<h2 id="官方下载地址"><a href="#官方下载地址" class="headerlink" title="官方下载地址"></a>官方下载地址</h2><p><a href="https://github.com/cymcsg/UltimateRecyclerView" target="_blank" rel="external">https://github.com/cymcsg/UltimateRecyclerView</a></p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在Gradle里加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">repositories &#123;</div><div class="line">    jcenter()</div><div class="line">    &#125;</div><div class="line">dependencies &#123;</div><div class="line">    ...</div><div class="line">    compile &apos;com.marshalchen.ultimaterecyclerview:library:0.7.3&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者maven里加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">  &lt;groupId&gt;com.marshalchen.ultimaterecyclerview&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;library&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;0.7.2&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在对应的layout.xml文件中加入<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">com.marshalchen.ultimaterecyclerview.UltimateRecyclerView</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/ultimate_recycler_view"</span></div><div class="line">/&gt;</div></pre></td></tr></table></figure></p>
<p>就可以使用了</p>
<h2 id="入门例子"><a href="#入门例子" class="headerlink" title="入门例子"></a>入门例子</h2><p>这里我们来模仿下支付宝的记账本里的滑动替换head的效果<br>列表里有不同的分组，每个分组有一个头部，这个头部会长期驻留在顶部，当下一个分组的头部移动到顶部时，替换头部。</p>
<p>下面是布局代码<br>activity_main.xml 主布局<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">com.marshalchen.ultimaterecyclerview.UltimateRecyclerView</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/recycler_view"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">        &gt;<span class="tag">&lt;/<span class="name">com.marshalchen.ultimaterecyclerview.UltimateRecyclerView</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>head_view.xml 头部的样式<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"60dp"</span></div><div class="line">    <span class="attr">android:background</span>=<span class="string">"@color/colorPrimary"</span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/tv2"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:padding</span>=<span class="string">"20dp"</span>&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"40dp"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"40dp"</span></div><div class="line">        <span class="attr">android:layout_gravity</span>=<span class="string">"right"</span></div><div class="line">        <span class="attr">android:src</span>=<span class="string">"@mipmap/ic_launcher"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>item_layout.xml  列表子布局<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/tv"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:padding</span>=<span class="string">"20dp"</span></div><div class="line">    <span class="attr">android:background</span>=<span class="string">"@color/colorAccent"</span>&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>以上就是布局的全部文件了</p>
<p>下面是程序的代码<br>MainActivity.java     主程序 Activity<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.example.asus.ultimaterecyclerviewtest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.os.Bundle;</div><div class="line"><span class="keyword">import</span> android.os.Handler;</div><div class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</div><div class="line"><span class="keyword">import</span> android.support.v7.widget.LinearLayoutManager;</div><div class="line"><span class="keyword">import</span> android.support.v7.widget.RecyclerView;</div><div class="line"><span class="keyword">import</span> android.support.v7.widget.helper.ItemTouchHelper;</div><div class="line"><span class="keyword">import</span> android.view.LayoutInflater;</div><div class="line"><span class="keyword">import</span> android.view.View;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.marshalchen.ultimaterecyclerview.UltimateRecyclerView;</div><div class="line"><span class="keyword">import</span> com.marshalchen.ultimaterecyclerview.itemTouchHelper.SimpleItemTouchHelperCallback;</div><div class="line"><span class="keyword">import</span> com.marshalchen.ultimaterecyclerview.stickyheadersrecyclerview.StickyRecyclerHeadersDecoration;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    UltimateRecyclerView recyclerView;</div><div class="line"></div><div class="line">    View headerView;</div><div class="line">    <span class="keyword">private</span> StringAdapter adapter;</div><div class="line">    <span class="keyword">private</span> Handler handler;</div><div class="line"></div><div class="line">    ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        <span class="comment">//生成数据</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</div><div class="line">            strings.add(i + <span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">        recyclerView = (UltimateRecyclerView) findViewById(R.id.recycler_view);</div><div class="line">        handler = <span class="keyword">new</span> Handler();</div><div class="line">        recyclerView.setLayoutManager(<span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>));</div><div class="line">        headerView = LayoutInflater.from(<span class="keyword">this</span>).inflate(R.layout.head_view, <span class="keyword">null</span>);</div><div class="line">        adapter = <span class="keyword">new</span> StringAdapter(strings, <span class="keyword">this</span>);</div><div class="line">        recyclerView.setAdapter(adapter);</div><div class="line"></div><div class="line">        <span class="comment">//为每个item添加头部的布局   这里运用到的其实就是RecyclerView.ItemDecoration</span></div><div class="line">        <span class="comment">//可能一般都是用这个来实现item之间的分隔线的  但是线也是一个view，但这个view够大的时候，就是一个头部了</span></div><div class="line">        StickyRecyclerHeadersDecoration stickyRecyclerHeadersDecoration = <span class="keyword">new</span> StickyRecyclerHeadersDecoration(adapter);</div><div class="line">        recyclerView.addItemDecoration(stickyRecyclerHeadersDecoration);</div><div class="line"></div><div class="line">        ItemTouchHelper.Callback callback = <span class="keyword">new</span> SimpleItemTouchHelperCallback(adapter) &#123;</div><div class="line">            <span class="comment">//这个方法还有别的方法可以重载  可以控制如滑动删除等功能</span></div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMovementFlags</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;<span class="comment">//控制拖动的方向   这里设置了智能上下拖动交换位置</span></div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> swipeFlags = ItemTouchHelper.LEFT;<span class="comment">//控制滑动删除的方向  这里设置了只能左滑删除</span></div><div class="line"></div><div class="line">                <span class="keyword">return</span> makeMovementFlags(dragFlags, swipeFlags);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isItemViewSwipeEnabled</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.isItemViewSwipeEnabled();<span class="comment">//这里控制开启或关闭item是否可以滑动删除的功能</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLongPressDragEnabled</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.isLongPressDragEnabled();<span class="comment">//控制长按拖动功能</span></div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> ItemTouchHelper itemTouchHelper = <span class="keyword">new</span> ItemTouchHelper(callback);</div><div class="line">        itemTouchHelper.attachToRecyclerView(recyclerView.mRecyclerView);</div><div class="line">        <span class="comment">//设置头部一定要在setAdapter后面，因为这个操作会调用adapter的方法来显示头部，如果adapter为null，则出错</span></div><div class="line">        recyclerView.setParallaxHeader(headerView);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>StringAdapter.java    数据适配器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.example.asus.ultimaterecyclerviewtest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.content.Context;</div><div class="line"><span class="keyword">import</span> android.support.v7.widget.RecyclerView;</div><div class="line"><span class="keyword">import</span> android.view.LayoutInflater;</div><div class="line"><span class="keyword">import</span> android.view.View;</div><div class="line"><span class="keyword">import</span> android.view.ViewGroup;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.marshalchen.ultimaterecyclerview.UltimateViewAdapter;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by asus on 2018/3/19.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringAdapter</span> <span class="keyword">extends</span> <span class="title">UltimateViewAdapter</span>&lt;<span class="title">StringViewHolder</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;String&gt; stringList;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Context context;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringAdapter</span><span class="params">(List&lt;String&gt; stringList, Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.stringList = stringList;</div><div class="line">        <span class="keyword">this</span>.context = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> StringViewHolder <span class="title">getViewHolder</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringViewHolder(view, <span class="keyword">false</span>);</div><div class="line">        <span class="comment">//这个getViewHolder方法在内部实现中只有在获取头部、加载更多、下拉刷新的时候会调用</span></div><div class="line">        <span class="comment">//直接设置itemView为GONE，所以不需要初始化什么的，只要返回的是个ViewHolder就行</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> StringViewHolder <span class="title">newFooterHolder</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> StringViewHolder <span class="title">newHeaderHolder</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> StringViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent)</span> </span>&#123;</div><div class="line">        View view = LayoutInflater.from(<span class="keyword">this</span>.context).inflate(R.layout.item_layout, parent, <span class="keyword">false</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringViewHolder(view, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAdapterItemCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> stringList == <span class="keyword">null</span> ? <span class="number">0</span> : stringList.size();</div><div class="line">        <span class="comment">//这里返回的是你的item的个数  不包括头部和加载view</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">generateHeaderId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (customHeaderView != <span class="keyword">null</span>) &#123;</div><div class="line">            position -= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//为每一项item生成头部的View，如果返回－1，则不生成，假如多个连续的item返回同一个id，</span></div><div class="line">        <span class="comment">//则只会生成一个头部View</span></div><div class="line">        <span class="comment">//这里提取position的第一个数作为id</span></div><div class="line">        String s = position + <span class="string">""</span>;</div><div class="line">        <span class="keyword">return</span> s.charAt(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(StringViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        <span class="comment">//一定要加这个判断  因为UltimateRecyclerView本身有加了头部和尾部  这个方法返回的是包括头部和尾部在内的</span></div><div class="line">        <span class="keyword">if</span> (position &lt; getItemCount() &amp;&amp; (customHeaderView</div><div class="line">                != <span class="keyword">null</span> ? position &lt;= stringList.size() : position &lt; stringList.size())</div><div class="line">                &amp;&amp; (customHeaderView != <span class="keyword">null</span> ? position &gt; <span class="number">0</span> : <span class="keyword">true</span>)) &#123;</div><div class="line">            position -= customHeaderView == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="number">1</span>;</div><div class="line">            holder.tv.setText(stringList.get(position));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> RecyclerView.<span class="function">ViewHolder <span class="title">onCreateHeaderViewHolder</span><span class="params">(ViewGroup parent)</span> </span>&#123;</div><div class="line">        View view = LayoutInflater.from(<span class="keyword">this</span>.context).inflate(R.layout.head_view, parent, <span class="keyword">false</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringHeadViewHolder(view);</div><div class="line">        <span class="comment">//初始化item的头部布局  这里为了方便 就直接用StringViewHolder,实际使用可以使用不同于item的布局</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindHeaderViewHolder</span><span class="params">(RecyclerView.ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (customHeaderView != <span class="keyword">null</span>) &#123;</div><div class="line">            position -= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//绑定item头部view的数据，这里提取每个view的position的第一个数来作为头部显示数据</span></div><div class="line">        ((StringHeadViewHolder) holder).tv2.setText(<span class="string">"header  "</span> + (position + <span class="string">" "</span>).charAt(<span class="number">0</span>));</div><div class="line">        ((StringHeadViewHolder) holder).tv2.setTextColor(<span class="keyword">this</span>.context.getResources().getColor(android.R.color.holo_red_dark));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemMove</span><span class="params">(<span class="keyword">int</span> fromPosition, <span class="keyword">int</span> toPosition)</span> </span>&#123;</div><div class="line">        swapPositions(stringList, fromPosition, toPosition);</div><div class="line"></div><div class="line">        <span class="comment">//如果开启的拖动移动位置的功能</span></div><div class="line">        <span class="comment">//要重写这个方法  因为如果不重写  交换的只是view的位置，数据的位置没有交换 一拖动，就会变成原来的样子</span></div><div class="line">        <span class="keyword">super</span>.onItemMove(fromPosition, toPosition);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemDismiss</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        removeInternal(stringList, position);<span class="comment">//控制删除的</span></div><div class="line">        <span class="keyword">super</span>.onItemDismiss(position);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>StringHeadViewHolder.java    头部的ViewHolder<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.example.asus.ultimaterecyclerviewtest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.view.View;</div><div class="line"><span class="keyword">import</span> android.widget.TextView;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.marshalchen.ultimaterecyclerview.UltimateRecyclerviewViewHolder;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by asus on 2018/3/17.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringHeadViewHolder</span> <span class="keyword">extends</span> <span class="title">UltimateRecyclerviewViewHolder</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> TextView tv2;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringHeadViewHolder</span><span class="params">(View itemView)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(itemView);</div><div class="line">        tv2 = (TextView) itemView.findViewById(R.id.tv2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>StringViewHolder.java  列表的ViewHolder<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> com.example.asus.ultimaterecyclerviewtest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.view.View;</div><div class="line"><span class="keyword">import</span> android.widget.TextView;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.marshalchen.ultimaterecyclerview.UltimateRecyclerviewViewHolder;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by asus on 2018/3/17.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringViewHolder</span> <span class="keyword">extends</span> <span class="title">UltimateRecyclerviewViewHolder</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> TextView tv;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringViewHolder</span><span class="params">(View itemView, <span class="keyword">boolean</span> isItem)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(itemView);</div><div class="line">        <span class="keyword">if</span> (isItem) &#123;</div><div class="line">            tv = (TextView) itemView;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里再说下关于viewholder知识。<br>ViewHolder通常出现在适配器里，为的是列表滚动的时候快速设置值，而不必每次都重新创建很多对象，从而提升性能。<br>也可以说是一个持有者的类，他里面一般没有方法，只有属性，作用就是一个临时的储存器，把你getView方法中每次返回的View存起来，可以下次再用。这样做的好处就是不必每次都到布局文件中去拿到你的View，提高了效率。</p>
<h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><video src="http://ow9eu3p52.bkt.clouddn.com/Screenrecorder-2018-03-19-13-52-14-486.mp4" type="video/mp4" controls="controls" width="33%" height="33%">
</video>


<h2 id="框架文档"><a href="#框架文档" class="headerlink" title="框架文档"></a>框架文档</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>UltimateRecyclerView是一个RecyclerView（高级和灵活版本的ListView），带有拉动刷新，加载更多，滑动解散，拖放和动画，粘滞标题，滚动显示或隐藏工具栏和FAB等许多功能。您可以使用它just like RecyclerView。</p>
</blockquote>
<p>当前版本: v0.7.0</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>Gradle:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">repositories &#123;</div><div class="line">    jcenter()</div><div class="line">    &#125;</div><div class="line">dependencies &#123;</div><div class="line">    ...</div><div class="line">    compile &apos;com.marshalchen.ultimaterecyclerview:library:0.7.3&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Maven:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">  &lt;groupId&gt;com.marshalchen.ultimaterecyclerview&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;library&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;0.7.2&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p>使用：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">com.marshalchen.ultimaterecyclerview.UltimateRecyclerView</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/ultimate_recycler_view"</span></div><div class="line">/&gt;</div></pre></td></tr></table></figure></p>
<p>一些demo：<br>我的demo 参考上文的入门例子部分</p>
<p><a href="https://github.com/cymcsg/UltimateRecyclerView/tree/master/UltimateRecyclerView" target="_blank" rel="external">官方demo</a></p>
<h2 id="自己对于框架的评价"><a href="#自己对于框架的评价" class="headerlink" title="自己对于框架的评价"></a>自己对于框架的评价</h2><p>我觉得这个框架可以说是对于原生的RecyclerView的一些补充<br>将一些实际使用中可能需要用到而官方没有提供的功能给整合了进来。<br>让一些刚开始接触列表这块功能的新人开发者专注于一块组件，而不用去各处寻找资料，方便了开发者。</p>
<p>但是因为是对于原生的RecyclerView的一些补充，所以容易造成一些安装上的报错，或者因为更新而产生版本不匹配的问题，相对于原来的RecyclerView，这可以说是这个框架的一个缺点了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果说项目里有用到RecyclerView的话&lt;br&gt;那么UItimateRecyclerView的使用能让你更加轻松的完成你想要的功能&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.chenwe.top/categories/Android/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>React Native开发中的一些坑 (二)</title>
    <link href="http://blog.chenwe.top/2018/03/08/2018/2018-03-08%20React%20Native%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%20(%E4%BA%8C)/"/>
    <id>http://blog.chenwe.top/2018/03/08/2018/2018-03-08 React Native开发中的一些坑 (二)/</id>
    <published>2018-03-08T11:34:08.100Z</published>
    <updated>2018-03-31T06:23:17.368Z</updated>
    
    <content type="html"><![CDATA[<p>这几天在弄React Native<br>中间难免踩坑<br>这里继续记录下</p>
<a id="more"></a>
<h2 id="Could-not-expand-ZIP"><a href="#Could-not-expand-ZIP" class="headerlink" title="Could not expand ZIP"></a>Could not expand ZIP</h2><p>问题描述：</p>
<blockquote>
<p>Execution failed for task ‘:app:prepareCameReactNativeCameraUnspecifiedLibrary’.<br>Could not expand ZIP ‘D:\ReactNative\came\node_modules\react-native-camera\android\build\outputs\aar\react-native-camera-release.aar’.</p>
</blockquote>
<p>解决方法：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">D:\ReactNative\came</div><div class="line">λ cd android</div><div class="line"></div><div class="line">D:\ReactNative\came\android</div><div class="line">λ gradlew clean</div><div class="line">Incremental java compilation is an incubating feature.</div><div class="line">:app:clean</div><div class="line">:react-native-camera:clean</div><div class="line"></div><div class="line">BUILD SUCCESSFUL</div><div class="line"></div><div class="line">Total time: 27.948 secs</div><div class="line">D:\ReactNative\came\android</div><div class="line">λ cd ..</div><div class="line"></div><div class="line">D:\ReactNative\came</div><div class="line">λ react-native run-android</div></pre></td></tr></table></figure></p>
<h2 id="java-io-IOException-Could-not-delete-path"><a href="#java-io-IOException-Could-not-delete-path" class="headerlink" title="java.io.IOException: Could not delete path"></a>java.io.IOException: Could not delete path</h2><p>问题描述：</p>
<blockquote>
<p>Execution failed for task ‘:app:transformClassesWithDexForDebug’.<br>java.io.IOException: Could not delete path ‘D:\ReactNative\came\android\app\build\intermediates\transforms\dex\debug\folders’.</p>
</blockquote>
<p>解决方法：<br>删除相关问题的node_module 然后重装。</p>
<h2 id="undefined-is-not-an-object-evaluating-this-props-navigation-navigate"><a href="#undefined-is-not-an-object-evaluating-this-props-navigation-navigate" class="headerlink" title="undefined is not an object (evaluating this.props.navigation.navigate)"></a>undefined is not an object (evaluating this.props.navigation.navigate)</h2><p>问题产生：<br>想从一个页面的组件中实现导航跳转<br>但是没有传入navigation这个props</p>
<p>解决方法：<br>传入navigation<br>例如 <me navigation="{this.props.navigation}/"></me></p>
<h2 id="图片点击没反应"><a href="#图片点击没反应" class="headerlink" title="图片点击没反应"></a>图片点击没反应</h2><p>图片之类的控件要在外面加上<code>TouchableWithoutFeedback</code> 才能监听点击</p>
<p>例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">TouchableWithoutFeedback</span> <span class="attr">onPress</span>=<span class="string">&#123;()</span> =&gt;</span> this.toTakePhoto()&#125; &gt;</div><div class="line">  <span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;styles.img_facewarpper&#125;</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">Image</span> <span class="attr">style</span>=<span class="string">&#123;styles.img_face&#125;</span></span></div><div class="line">          <span class="attr">source</span>=<span class="string">&#123;require(</span>'<span class="attr">.</span>/<span class="attr">components</span>/<span class="attr">img</span>/<span class="attr">face.png</span>')&#125; /&gt;</div><div class="line">  <span class="tag">&lt;/<span class="name">View</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">TouchableWithoutFeedback</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="Undefined-is-not-an-object-evaluating-this-state"><a href="#Undefined-is-not-an-object-evaluating-this-state" class="headerlink" title="Undefined is not an object evaluating this.state.*"></a>Undefined is not an object evaluating this.state.*</h2><p>这个state的值取不到，说是未定义。</p>
<p>我们只要在对应调用的方法后面加上 <code>.bind(this)</code> 就好了。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 错误</div><div class="line">renderHeader=&#123;this._renderHeader&#125;</div><div class="line"></div><div class="line">// 正确</div><div class="line">renderHeader=&#123;this._renderHeader.bind(this)&#125;</div></pre></td></tr></table></figure></p>
<p>上面那种方法，在_renderHeader里的state是取不到的<br>要像下面那种方法那样.bing(this)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天在弄React Native&lt;br&gt;中间难免踩坑&lt;br&gt;这里继续记录下&lt;/p&gt;
    
    </summary>
    
      <category term="React Native" scheme="http://blog.chenwe.top/categories/React-Native/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>React Native开发中的一些坑（一）</title>
    <link href="http://blog.chenwe.top/2018/03/07/2018/2018-03-07%20React%20Native%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    <id>http://blog.chenwe.top/2018/03/07/2018/2018-03-07 React Native开发中的一些坑/</id>
    <published>2018-03-07T14:19:02.214Z</published>
    <updated>2018-03-07T14:39:19.419Z</updated>
    
    <content type="html"><![CDATA[<p>这几天在弄React Native<br>中间难免踩坑<br>这里记录下</p>
<a id="more"></a>
<h2 id="Configuration-with-name-‘default’-not-found-react-native"><a href="#Configuration-with-name-‘default’-not-found-react-native" class="headerlink" title="Configuration with name ‘default’ not found react-native"></a>Configuration with name ‘default’ not found react-native</h2><p>引入一些库再去运行，可能会报的错<br>原因：因为 android目录下的settings.gradle文件里有些东西的引用和node_modules里不同<br>解决方法： 删掉其中缺失的部分，重新安装。</p>
<h2 id="react-native-camera-相关的错误"><a href="#react-native-camera-相关的错误" class="headerlink" title="react-native-camera 相关的错误"></a>react-native-camera 相关的错误</h2><h3 id="react-native-camera-unspecified"><a href="#react-native-camera-unspecified" class="headerlink" title="react-native-camera:unspecified"></a>react-native-camera:unspecified</h3><p>在 <code>react-native link react-native-camera</code> 之后容易报的错<br>原因：因为没有在 android/build.gradle 文件里添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">maven &#123; url &apos;https://jitpack.io&apos; &#125;</div></pre></td></tr></table></figure></p>
<p>注意：添加到上一个maven的下面就行，中间不用加 ,<br>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">maven &#123; url &apos;https://jitpack.io&apos; &#125;</div><div class="line">maven &#123;</div><div class="line">    url &quot;https://maven.google.com&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即可</p>
<h3 id="Could-not-find-com-android-support-support-v4-26-0-1"><a href="#Could-not-find-com-android-support-support-v4-26-0-1" class="headerlink" title="Could not find com.android.support:support-v4:26.0.1."></a>Could not find com.android.support:support-v4:26.0.1.</h3><p>在 <code>react-native link react-native-camera</code> 之后容易报的错<br>原因：因为build tool 版本太低吗，要求26<br>解决方法：升级。<br>在android/app目录里，修改 build.gradle 里的版本信息为26<br>例如修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">compileSdkVersion 26</div><div class="line">buildToolsVersion &quot;26.0.1&quot;</div><div class="line"></div><div class="line">defaultConfig &#123;</div><div class="line">    applicationId &quot;com.came&quot;</div><div class="line">    minSdkVersion 16</div><div class="line">    targetSdkVersion 26</div><div class="line">    versionCode 1</div><div class="line">    versionName &quot;1.0&quot;</div><div class="line">    ndk &#123;</div><div class="line">        abiFilters &quot;armeabi-v7a&quot;, &quot;x86&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>修改之后也还是不行，要在android/build.gradle 文件里添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">maven &#123;</div><div class="line">    url &quot;https://maven.google.com&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天在弄React Native&lt;br&gt;中间难免踩坑&lt;br&gt;这里记录下&lt;/p&gt;
    
    </summary>
    
      <category term="React Native" scheme="http://blog.chenwe.top/categories/React-Native/"/>
    
    
      <category term="study" scheme="http://blog.chenwe.top/tags/study/"/>
    
      <category term="code" scheme="http://blog.chenwe.top/tags/code/"/>
    
  </entry>
  
</feed>
